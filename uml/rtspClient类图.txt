@startuml


class Medium {
    + static Boolean lookupByName(UsageEnvironment& env, char const* mediumName, Medium*& resultMedium);
    + static void close(UsageEnvironment& env, char const* mediumName);
    + static void close(Medium* medium); // alternative close() method using ptrs
    + UsageEnvironment& envir() const { return fEnviron; }
    + char const* name() const { return fMediumName; }
    + virtual Boolean isSource() const;
    + virtual Boolean isSink() const;
    + virtual Boolean isRTCPInstance() const;
    + virtual Boolean isRTSPClient() const;
    + virtual Boolean isRTSPServer() const;
    + virtual Boolean isMediaSession() const;
    + virtual Boolean isServerMediaSession() const;
    + virtual Boolean isDarwinInjector() const;
    # friend class MediaLookupTable;
    # Medium(UsageEnvironment& env);
    # virtual ~Medium();
    # TaskToken& nextTask();
    - UsageEnvironment& fEnviron;
    - char fMediumName[mediumNameMaxLen];
    - TaskToken fNextTask;
}


class RTSPClient {
    + static RTSPClient* createNew(UsageEnvironment& env, char const* rtspURL,
          int verbosityLevel = 0,
          char const* applicationName = NULL,
          portNumBits tunnelOverHTTPPortNum = 0,
          int socketNumToServer = -1);
    + typedef void(responseHandler)(RTSPClient* rtspClient,
          int resultCode, char* resultString);
    + unsigned sendDescribeCommand(responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendOptionsCommand(responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendAnnounceCommand(char const* sdpDescription, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendSetupCommand(MediaSubsession& subsession, responseHandler* responseHandler,
          Boolean streamOutgoing = False,
          Boolean streamUsingTCP = False,
          Boolean forceMulticastOnUnspecified = False,
          Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSession& session, responseHandler* responseHandler,
    +     double start = 0.0f, double end = -1.0f, float scale = 1.0f,
    +     Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSubsession& subsession, responseHandler* responseHandler,
          double start = 0.0f, double end = -1.0f, float scale = 1.0f,
          Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSession& session, responseHandler* responseHandler,
          char const* absStartTime, char const* absEndTime = NULL, float scale = 1.0f,
          Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSubsession& subsession, responseHandler* responseHandler,
          char const* absStartTime, char const* absEndTime = NULL, float scale = 1.0f,
          Authenticator* authenticator = NULL);
    + unsigned sendPauseCommand(MediaSession& session, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendPauseCommand(MediaSubsession& subsession, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendRecordCommand(MediaSession& session, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendRecordCommand(MediaSubsession& subsession, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendTeardownCommand(MediaSession& session, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendTeardownCommand(MediaSubsession& subsession, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendSetParameterCommand(MediaSession& session, responseHandler* responseHandler,
          char const* parameterName, char const* parameterValue,
          Authenticator* authenticator = NULL);
    + unsigned sendGetParameterCommand(MediaSession& session, responseHandler* responseHandler, char const* parameterName,
          Authenticator* authenticator = NULL);
    + void sendDummyUDPPackets(MediaSession& session, unsigned numDummyPackets = 2);
    + void sendDummyUDPPackets(MediaSubsession& subsession, unsigned numDummyPackets = 2);
    + void setSpeed(MediaSession& session, float speed = 1.0f);
    + Boolean changeResponseHandler(unsigned cseq, responseHandler* newResponseHandler);
    + int socketNum() const { return fInputSocketNum; }
    + static Boolean lookupByName(UsageEnvironment& env,
          char const* sourceName,
          RTSPClient*& resultClient);
    + static Boolean parseRTSPURL(UsageEnvironment& env, char const* url,
          char*& username, char*& password, NetAddress& address, portNumBits& portNum, char const** urlSuffix = NULL);
    + void setUserAgentString(char const* userAgentName);
    + void disallowBasicAuthentication() { fAllowBasicAuthentication = False; }
    + unsigned sessionTimeoutParameter() const { return fSessionTimeoutParameter; }
    + char const* url() const { return fBaseURL; }
    + static unsigned responseBufferSize;
    # RTSPClient(UsageEnvironment& env, char const* rtspURL,
          int verbosityLevel, char const* applicationName, portNumBits tunnelOverHTTPPortNum, int socketNumToServer);
    # virtual ~RTSPClient();
    # void reset();
    # void setBaseURL(char const* url);
    # int grabSocket(); // allows a subclass to reuse our input socket, so that it won't get closed when we're deleted
    # virtual unsigned sendRequest(RequestRecord* request);
    # virtual Boolean setRequestFields(RequestRecord* request,
        char*& cmdURL, Boolean& cmdURLWasAllocated,
        char const*& protocolStr,
        char*& extraHeaders, Boolean& extraHeadersWereAllocated);
    - virtual Boolean isRTSPClient() const;
    - void resetTCPSockets();
    - void resetResponseBuffer();
    - int openConnection(); // -1: failure; 0: pending; 1: success
    - int connectToServer(int socketNum, portNumBits remotePortNum); // used to implement "openConnection()"; result values are the same
    - char* createAuthenticatorString(char const* cmd, char const* url);
    - char* createBlocksizeString(Boolean streamUsingTCP);
    - void handleRequestError(RequestRecord* request);
    - Boolean parseResponseCode(char const* line, unsigned& responseCode, char const*& responseString);
    - void handleIncomingRequest();
    - static Boolean checkForHeader(char const* line, char const* headerName, unsigned headerNameLength, char const*& headerParams);
    - Boolean parseTransportParams(char const* paramsStr,
          char*& serverAddressStr, portNumBits& serverPortNum,
          unsigned char& rtpChannelId, unsigned char& rtcpChannelId);
    - Boolean parseScaleParam(char const* paramStr, float& scale);
    - Boolean parseSpeedParam(char const* paramStr, float& speed);
    - Boolean parseRTPInfoParams(char const*& paramStr, u_int16_t& seqNum, u_int32_t& timestamp);
    - Boolean handleSETUPResponse(MediaSubsession& subsession, char const* sessionParamsStr, char const* transportParamsStr,
          Boolean streamUsingTCP);
    - Boolean handlePLAYResponse(MediaSession& session, MediaSubsession& subsession,
          char const* scaleParamsStr, const char* speedParamsStr,
          char const* rangeParamsStr, char const* rtpInfoParamsStr);
    - Boolean handleTEARDOWNResponse(MediaSession& session, MediaSubsession& subsession);
    - Boolean handleGET_PARAMETERResponse(char const* parameterName, char*& resultValueString);
    - Boolean handleAuthenticationFailure(char const* wwwAuthenticateParamsStr);
    - Boolean resendCommand(RequestRecord* request);
    - char const* sessionURL(MediaSession const& session) const;
    - static void handleAlternativeRequestByte(void*, u_int8_t requestByte);
    - void handleAlternativeRequestByte1(u_int8_t requestByte);
    - void constructSubsessionURL(MediaSubsession const& subsession,
          char const*& prefix,
          char const*& separator,
          char const*& suffix);
    - Boolean setupHTTPTunneling1(); // send the HTTP "GET"
    - static void responseHandlerForHTTP_GET(RTSPClient* rtspClient, int responseCode, char* responseString);
    - void responseHandlerForHTTP_GET1(int responseCode, char* responseString);
    - Boolean setupHTTPTunneling2(); // send the HTTP "POST"
    - static void connectionHandler(void*, int /*mask*/);
    - void connectionHandler1();
    - static void incomingDataHandler(void*, int /*mask*/);
    - void incomingDataHandler1();
    - void handleResponseBytes(int newBytesRead);
    + u_int16_t desiredMaxIncomingPacketSize;
    # int fVerbosityLevel;
    # unsigned fCSeq;
    # Authenticator fCurrentAuthenticator;
    # Boolean fAllowBasicAuthentication;
    # netAddressBits fServerAddress;
    - portNumBits fTunnelOverHTTPPortNum;
    - char* fUserAgentHeaderStr;
    - unsigned fUserAgentHeaderStrLen;
    - int fInputSocketNum, fOutputSocketNum;
    - char* fBaseURL;
    - unsigned char fTCPStreamIdCount; // used for (optional) RTP/TCP
    - char* fLastSessionId;
    - unsigned fSessionTimeoutParameter; // optionally set in response "Session:" headers
    - char* fResponseBuffer;
    - unsigned fResponseBytesAlreadySeen, fResponseBufferBytesLeft;
    - RequestQueue fRequestsAwaitingConnection, fRequestsAwaitingHTTPTunneling, fRequestsAwaitingResponse;
    - char fSessionCookie[33];
    - unsigned fSessionCookieCounter;
    - Boolean fHTTPTunnelingConnectionIsPending;
}


class RequestQueue {
    + RequestQueue();
    + RequestQueue(RequestQueue& origQueue);
    + virtual ~RequestQueue();
    + void enqueue(RequestRecord* request);
    + RequestRecord* dequeue();
    + void putAtHead(RequestRecord* request);
    + RequestRecord* findByCSeq(unsigned cseq);
    + Boolean isEmpty() const { return fHead == NULL; }
    - RequestRecord* fHead;
    - RequestRecord* fTail;
}


class RequestRecord {
    + RequestRecord(unsigned cseq, char const* commandName, responseHandler* handler,
          MediaSession* session = NULL, MediaSubsession* subsession = NULL, u_int32_t booleanFlags = 0,
          double start = 0.0f, double end = -1.0f, float scale = 1.0f, char const* contentStr = NULL);
    + RequestRecord(unsigned cseq, responseHandler* handler,
          char const* absStartTime, char const* absEndTime = NULL, float scale = 1.0f,
          MediaSession* session = NULL, MediaSubsession* subsession = NULL);
    + virtual ~RequestRecord();
    + RequestRecord*& next() { return fNext; }
    + unsigned& cseq() { return fCSeq; }
    + char const* commandName() const { return fCommandName; }
    + MediaSession* session() const { return fSession; }
    + MediaSubsession* subsession() const { return fSubsession; }
    + u_int32_t booleanFlags() const { return fBooleanFlags; }
    + double start() const { return fStart; }
    + double end() const { return fEnd; }
    + char const* absStartTime() const { return fAbsStartTime; }
    + char const* absEndTime() const { return fAbsEndTime; }
    + float scale() const { return fScale; }
    + char* contentStr() const { return fContentStr; }
    + responseHandler*& handler() { return fHandler; }
    - RequestRecord* fNext;
    - unsigned fCSeq;
    - char const* fCommandName;
    - MediaSession* fSession;
    - MediaSubsession* fSubsession;
    - u_int32_t fBooleanFlags;
    - double fStart, fEnd;
    - char *fAbsStartTime, *fAbsEndTime;
    - float fScale;
    - char* fContentStr;
    - responseHandler* fHandler;
}


class ProxyRTSPClient {
    + ProxyRTSPClient(class ProxyServerMediaSession& ourServerMediaSession, char const* rtspURL,
        char const* username, char const* password,
        portNumBits tunnelOverHTTPPortNum, int verbosityLevel, int socketNumToServer);
    + virtual ~ProxyRTSPClient();
    + void continueAfterDESCRIBE(char const* sdpDescription);
    + void continueAfterLivenessCommand(int resultCode, Boolean serverSupportsGetParameter);
    + void continueAfterSETUP();
    - void reset();
    - Authenticator* auth() { return fOurAuthenticator; }
    - void scheduleLivenessCommand();
    - static void sendLivenessCommand(void* clientData);
    - void scheduleDESCRIBECommand();
    - static void sendDESCRIBE(void* clientData);
    - static void subsessionTimeout(void* clientData);
    - void handleSubsessionTimeout();
    - friend class ProxyServerMediaSession;
    - friend class ProxyServerMediaSubsession;
    - ProxyServerMediaSession& fOurServerMediaSession;
    - char* fOurURL;
    - Authenticator* fOurAuthenticator;
    - Boolean fStreamRTPOverTCP;
    - class ProxyServerMediaSubsession *fSetupQueueHead, *fSetupQueueTail;
    - unsigned fNumSetupsDone;
    - unsigned fNextDESCRIBEDelay; // in seconds
    - Boolean fServerSupportsGetParameter, fLastCommandWasPLAY;
    - TaskToken fLivenessCommandTask, fDESCRIBECommandTask, fSubsessionTimerTask;
}


class ServerMediaSession {
    + static ServerMediaSession* createNew(UsageEnvironment& env,
                        char const* streamName = NULL,
                        char const* info = NULL,
                        char const* description = NULL,
                        Boolean isSSM = False,
                        char const* miscSDPLines = NULL);
    + static Boolean lookupByName(UsageEnvironment& env,
                                char const* mediumName,
                                ServerMediaSession*& resultSession);
    + char* generateSDPDescription(); // based on the entire session
    + char const* streamName() const { return fStreamName; }
    + Boolean addSubsession(ServerMediaSubsession* subsession);
    + unsigned numSubsessions() const { return fSubsessionCounter; }
    + void testScaleFactor(float& scale); // sets "scale" to the actual supported scale
    + float duration() const;
    + unsigned referenceCount() const { return fReferenceCount; }
    + void incrementReferenceCount() { ++fReferenceCount; }
    + void decrementReferenceCount() { if (fReferenceCount > 0) --fReferenceCount; }
    + Boolean& deleteWhenUnreferenced() { return fDeleteWhenUnreferenced; }
    + void deleteAllSubsessions();
    # ServerMediaSession(UsageEnvironment& env, char const* streamName,
                char const* info, char const* description,
                Boolean isSSM, char const* miscSDPLines);
    # virtual ~ServerMediaSession();
    - virtual Boolean isServerMediaSession() const;
    - Boolean fIsSSM;
    - friend class ServerMediaSubsessionIterator;
    - ServerMediaSubsession* fSubsessionsHead;
    - ServerMediaSubsession* fSubsessionsTail;
    - unsigned fSubsessionCounter;
    - char* fStreamName;
    - char* fInfoSDPString;
    - char* fDescriptionSDPString;
    - char* fMiscSDPLines;
    - struct timeval fCreationTime;
    - unsigned fReferenceCount;
    - Boolean fDeleteWhenUnreferenced;
}


class ServerMediaSubsession {
    + unsigned trackNumber() const { return fTrackNumber; }
    + char const* trackId();
    + virtual char const* sdpLines() = 0;
    + virtual void getStreamParameters(unsigned clientSessionId, // in
                    netAddressBits clientAddress, // in
                    Port const& clientRTPPort, // in
                    Port const& clientRTCPPort, // in
                    int tcpSocketNum, // in (-1 means use UDP, not TCP)
                    unsigned char rtpChannelId, // in (used if TCP)
                    unsigned char rtcpChannelId, // in (used if TCP)
                    netAddressBits& destinationAddress, // in out
                    u_int8_t& destinationTTL, // in out
                    Boolean& isMulticast, // out
                    Port& serverRTPPort, // out
                    Port& serverRTCPPort, // out
                    void*& streamToken // out
                    ) = 0;
    + virtual void startStream(unsigned clientSessionId, void* streamToken,
                TaskFunc* rtcpRRHandler,
                void* rtcpRRHandlerClientData,
                unsigned short& rtpSeqNum,
                unsigned& rtpTimestamp,
                ServerRequestAlternativeByteHandler* serverRequestAlternativeByteHandler,
                void* serverRequestAlternativeByteHandlerClientData) = 0;
    + virtual void pauseStream(unsigned clientSessionId, void* streamToken);
    + virtual void seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT,
                double streamDuration, u_int64_t& numBytes);
    + virtual void seekStream(unsigned clientSessionId, void* streamToken, char*& absStart, char*& absEnd);
    + virtual void nullSeekStream(unsigned clientSessionId, void* streamToken,
                    double streamEndTime, u_int64_t& numBytes);
    + virtual void setStreamScale(unsigned clientSessionId, void* streamToken, float scale);
    + virtual float getCurrentNPT(void* streamToken);
    + virtual FramedSource* getStreamSource(void* streamToken);
    + virtual void deleteStream(unsigned clientSessionId, void*& streamToken);
    + virtual void testScaleFactor(float& scale); // sets "scale" to the actual supported scale
    + virtual float duration() const;
    + virtual void getAbsoluteTimeRange(char*& absStartTime, char*& absEndTime) const;
    + void setServerAddressAndPortForSDP(netAddressBits addressBits,
                        portNumBits portBits);
    # ServerMediaSubsession(UsageEnvironment& env);
    # virtual ~ServerMediaSubsession();
    # char const* rangeSDPLine() const;
    # ServerMediaSession* fParentSession;
    # netAddressBits fServerAddressForSDP;
    # portNumBits fPortNumForSDP;
    - friend class ServerMediaSession;
    - friend class ServerMediaSubsessionIterator;
    - ServerMediaSubsession* fNext;
    - unsigned fTrackNumber;
    - char const* fTrackId;
}


class ServerMediaSubsessionIterator {
    + ServerMediaSubsessionIterator(ServerMediaSession& session);
    + virtual ~ServerMediaSubsessionIterator();
    + ServerMediaSubsession* next(); // NULL if none
    + void reset();
    - ServerMediaSession& fOurSession;
    - ServerMediaSubsession* fNextPtr;
}


class ProxyServerMediaSession {
    + static ProxyServerMediaSession* createNew(UsageEnvironment& env,
        RTSPServer* ourRTSPServer,
        char const* inputStreamURL,
        char const* streamName = NULL,
        char const* username = NULL, char const* password = NULL,
        portNumBits tunnelOverHTTPPortNum = 0,
        int verbosityLevel = 0,
        int socketNumToServer = -1);
    + virtual ~ProxyServerMediaSession();
    + char const* url() const;
    + char describeCompletedFlag;
    + Boolean describeCompletedSuccessfully() const { return fClientMediaSession != NULL; }
    # ProxyServerMediaSession(UsageEnvironment& env, RTSPServer* ourRTSPServer,
        char const* inputStreamURL, char const* streamName,
        char const* username, char const* password,
        portNumBits tunnelOverHTTPPortNum, int verbosityLevel,
        int socketNumToServer,
        createNewProxyRTSPClientFunc* ourCreateNewProxyRTSPClientFunc
        = defaultCreateNewProxyRTSPClientFunc);
    # RTSPServer* fOurRTSPServer;
    # ProxyRTSPClient* fProxyRTSPClient;
    # MediaSession* fClientMediaSession;
    - friend class ProxyRTSPClient;
    - friend class ProxyServerMediaSubsession;
    - void continueAfterDESCRIBE(char const* sdpDescription);
    - void resetDESCRIBEState(); // undoes what was done by "contineAfterDESCRIBE()"
    - int fVerbosityLevel;
    - class PresentationTimeSessionNormalizer* fPresentationTimeSessionNormalizer;
    - createNewProxyRTSPClientFunc* fCreateNewProxyRTSPClientFunc;
}


class FramedSource {
    + static Boolean lookupByName(UsageEnvironment& env, char const* sourceName,
          FramedSource*& resultSource);
    + typedef void(afterGettingFunc)(void* clientData, unsigned frameSize,
          unsigned numTruncatedBytes,
          struct timeval presentationTime,
          unsigned durationInMicroseconds);
    + typedef void(onCloseFunc)(void* clientData);
    + void getNextFrame(unsigned char* to, unsigned maxSize,
          afterGettingFunc* afterGettingFunc,
          void* afterGettingClientData,
          onCloseFunc* onCloseFunc,
          void* onCloseClientData);
    + static void handleClosure(void* clientData);
    + void handleClosure();
    + void stopGettingFrames();
    + virtual unsigned maxFrameSize() const;
    + virtual void doGetNextFrame() = 0;
    + Boolean isCurrentlyAwaitingData() const;
    + static void afterGetting(FramedSource* source);
    # FramedSource(UsageEnvironment& env);
    # virtual ~FramedSource();
    # virtual void doStopGettingFrames();
    # unsigned char* fTo;
    # unsigned fMaxSize;
    # unsigned fFrameSize;
    # unsigned fNumTruncatedBytes;
    # struct timeval fPresentationTime;
    # unsigned fDurationInMicroseconds;
    - virtual Boolean isFramedSource() const;
    - afterGettingFunc* fAfterGettingFunc;
    - void* fAfterGettingClientData;
    - onCloseFunc* fOnCloseFunc;
    - void* fOnCloseClientData;
    - Boolean fIsCurrentlyAwaitingData;
}


class FramedFilter {
    + FramedSource* inputSource() const;
    + void reassignInputSource(FramedSource* newInputSource);
    + void detachInputSource();
    # FramedFilter(UsageEnvironment& env, FramedSource* inputSource);
    # virtual ~FramedFilter();
    # virtual char const* MIMEtype() const;
    # virtual void getAttributes() const;
    # virtual void doStopGettingFrames();
    # FramedSource* fInputSource;
}


class PresentationTimeSubsessionNormalizer {
    + void setRTPSink(RTPSink* rtpSink);
    - friend class PresentationTimeSessionNormalizer;
    - PresentationTimeSubsessionNormalizer(PresentationTimeSessionNormalizer& parent, FramedSource* inputSource, RTPSource* rtpSource,
          char const* codecName, PresentationTimeSubsessionNormalizer* next);
    - virtual ~PresentationTimeSubsessionNormalizer();
    - static void afterGettingFrame(void* clientData, unsigned frameSize, unsigned numTruncatedBytes,
          struct timeval presentationTime, unsigned durationInMicroseconds);
    - void afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime, unsigned durationInMicroseconds);
    - virtual void doGetNextFrame();
    - PresentationTimeSessionNormalizer& fParent;
    - RTPSource* fRTPSource;
    - RTPSink* fRTPSink;
    - char const* fCodecName;
    - PresentationTimeSubsessionNormalizer* fNext;
}


class PresentationTimeSessionNormalizer {
    + PresentationTimeSessionNormalizer(UsageEnvironment& env);
    + virtual ~PresentationTimeSessionNormalizer();
    + PresentationTimeSubsessionNormalizer*
    + createNewPresentationTimeSubsessionNormalizer(FramedSource* inputSource, RTPSource* rtpSource, char const* codecName);

    - friend class PresentationTimeSubsessionNormalizer;
    - void normalizePresentationTime(PresentationTimeSubsessionNormalizer* ssNormalizer,
          struct timeval& toPT, struct timeval const& fromPT);
    - void removePresentationTimeSubsessionNormalizer(PresentationTimeSubsessionNormalizer* ssNormalizer);
    - PresentationTimeSubsessionNormalizer* fSubsessionNormalizers;
    - PresentationTimeSubsessionNormalizer* fMasterSSNormalizer;
    - struct timeval fPTAdjustment;
}


class OnDemandServerMediaSubsession {
    protected: // we're a virtual base class
    # OnDemandServerMediaSubsession(UsageEnvironment& env, Boolean reuseFirstSource,
                portNumBits initialPortNum = 6970,
                Boolean multiplexRTCPWithRTP = False);
    # virtual ~OnDemandServerMediaSubsession();
    # virtual char const* sdpLines();
    # virtual void getStreamParameters(unsigned clientSessionId,
                                        netAddressBits clientAddress,
                                        Port const& clientRTPPort,
                                        Port const& clientRTCPPort,
                                        int tcpSocketNum,
                                        unsigned char rtpChannelId,
                                        unsigned char rtcpChannelId,
                                        netAddressBits& destinationAddress,
                                        u_int8_t& destinationTTL,
                                        Boolean& isMulticast,
                                        Port& serverRTPPort,
                                        Port& serverRTCPPort,
                                        void*& streamToken);
    # virtual void startStream(unsigned clientSessionId, void* streamToken,
                                TaskFunc* rtcpRRHandler,
                                void* rtcpRRHandlerClientData,
                                unsigned short& rtpSeqNum,
                                unsigned& rtpTimestamp,
                                ServerRequestAlternativeByteHandler* serverRequestAlternativeByteHandler,
                                void* serverRequestAlternativeByteHandlerClientData);
    # virtual void pauseStream(unsigned clientSessionId, void* streamToken);
    # virtual void seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT, double streamDuration, u_int64_t& numBytes);
    # virtual void seekStream(unsigned clientSessionId, void* streamToken, char*& absStart, char*& absEnd);
    # virtual void nullSeekStream(unsigned clientSessionId, void* streamToken,
                      double streamEndTime, u_int64_t& numBytes);
    # virtual void setStreamScale(unsigned clientSessionId, void* streamToken, float scale);
    # virtual float getCurrentNPT(void* streamToken);
    # virtual FramedSource* getStreamSource(void* streamToken);
    # virtual void deleteStream(unsigned clientSessionId, void*& streamToken);
    # virtual char const* getAuxSDPLine(RTPSink* rtpSink,
                      FramedSource* inputSource);
    # virtual void seekStreamSource(FramedSource* inputSource, double& seekNPT, double streamDuration, u_int64_t& numBytes);
    # virtual void seekStreamSource(FramedSource* inputSource, char*& absStart, char*& absEnd);
    # virtual void setStreamSourceScale(FramedSource* inputSource, float scale);
    # virtual void setStreamSourceDuration(FramedSource* inputSource, double streamDuration, u_int64_t& numBytes);
    # virtual void closeStreamSource(FramedSource* inputSource);
    # protected: // new virtual functions, defined by all subclasses
    # virtual FramedSource* createNewStreamSource(unsigned clientSessionId,
                              unsigned& estBitrate) = 0;
    # virtual RTPSink* createNewRTPSink(Groupsock* rtpGroupsock,
                      unsigned char rtpPayloadTypeIfDynamic,
                      FramedSource* inputSource) = 0;
    # virtual Groupsock* createGroupsock(struct in_addr const& addr, Port port);
    + void multiplexRTCPWithRTP() { fMultiplexRTCPWithRTP = True; }
    + void setRTCPAppPacketHandler(RTCPAppHandlerFunc* handler, void* clientData);
    + void sendRTCPAppPacket(u_int8_t subtype, char const* name,
                u_int8_t* appDependentData, unsigned appDependentDataSize);
    - void setSDPLinesFromRTPSink(RTPSink* rtpSink, FramedSource* inputSource,
                    unsigned estBitrate);
    # char* fSDPLines;
    # HashTable* fDestinationsHashTable; // indexed by client session id
    # private:
    # Boolean fReuseFirstSource;
    # portNumBits fInitialPortNum;
    # Boolean fMultiplexRTCPWithRTP;
    # void* fLastStreamToken;
    # char fCNAME[100]; // for RTCP
    # RTCPAppHandlerFunc* fAppHandlerTask;
    # void* fAppHandlerClientData;
    # friend class StreamState;
}


class Destinations {
    + Destinations(struct in_addr const& destAddr,
                    Port const& rtpDestPort,
                    Port const& rtcpDestPort);
    + Destinations(int tcpSockNum, unsigned char rtpChanId, unsigned char rtcpChanId);
    + Boolean isTCP;
    + struct in_addr addr;
    + Port rtpPort;
    + Port rtcpPort;
    + int tcpSocketNum;
    + unsigned char rtpChannelId, rtcpChannelId;
}


class StreamState {
    + StreamState(OnDemandServerMediaSubsession& master,
                Port const& serverRTPPort, Port const& serverRTCPPort,
                RTPSink* rtpSink, BasicUDPSink* udpSink,
                unsigned totalBW, FramedSource* mediaSource,
                Groupsock* rtpGS, Groupsock* rtcpGS);
    + virtual ~StreamState();
    + void startPlaying(Destinations* destinations,
                        TaskFunc* rtcpRRHandler, void* rtcpRRHandlerClientData,
                        ServerRequestAlternativeByteHandler* serverRequestAlternativeByteHandler,
                        void* serverRequestAlternativeByteHandlerClientData);
    + void pause();
    + void sendRTCPAppPacket(u_int8_t subtype, char const* name,
                u_int8_t* appDependentData, unsigned appDependentDataSize);
    + void endPlaying(Destinations* destinations);
    + void reclaim();
    + unsigned& referenceCount() { return fReferenceCount; }
    + Port const& serverRTPPort() const { return fServerRTPPort; }
    + Port const& serverRTCPPort() const { return fServerRTCPPort; }
    + RTPSink* rtpSink() const { return fRTPSink; }
    + float streamDuration() const { return fStreamDuration; }
    + FramedSource* mediaSource() const { return fMediaSource; }
    + float& startNPT() { return fStartNPT; }
    + private:
    + OnDemandServerMediaSubsession& fMaster;
    + Boolean fAreCurrentlyPlaying;
    + unsigned fReferenceCount;
    + Port fServerRTPPort, fServerRTCPPort;
    + RTPSink* fRTPSink;
    + BasicUDPSink* fUDPSink;
    + float fStreamDuration;
    + unsigned fTotalBW;
    + RTCPInstance* fRTCPInstance;
    + FramedSource* fMediaSource;
    + float fStartNPT;
    + Groupsock* fRTPgs;
    + Groupsock* fRTCPgs;
}


class ProxyServerMediaSubsession {
    + ProxyServerMediaSubsession(MediaSubsession& mediaSubsession);
    + virtual ~ProxyServerMediaSubsession();
    + char const* codecName() const { return fClientMediaSubsession.codecName(); }
    + char const* mediumName() const { return fClientMediaSubsession.mediumName(); }
    + unsigned char rtpPayloadFormat() const { return fClientMediaSubsession.rtpPayloadFormat(); }
    + virtual FramedSource* createNewStreamSource(unsigned clientSessionId,
          unsigned& estBitrate);
    + virtual void closeStreamSource(FramedSource* inputSource);
    + virtual RTPSink* createNewRTPSink(Groupsock* rtpGroupsock,
        unsigned char rtpPayloadTypeIfDynamic,
        FramedSource* inputSource);
    - static void subsessionByeHandler(void* clientData);
    - void subsessionByeHandler();
    - int verbosityLevel() const { return ((ProxyServerMediaSession*)fParentSession)->fVerbosityLevel; }
    - friend class ProxyRTSPClient;
    - MediaSubsession& fClientMediaSubsession; // the 'client' media subsession object that corresponds to this 'server' media subsession
    - ProxyServerMediaSubsession* fNext; // used when we're part of a queue
    - Boolean fHaveSetupStream;
}


class HandlerServerForREGISTERCommand {
    + static HandlerServerForREGISTERCommand* createNew(UsageEnvironment& env, onRTSPClientCreationFunc* creationFunc,
        Port ourPort = 0, UserAuthenticationDatabase* authDatabase = NULL,
        int verbosityLevel = 0, char const* applicationName = NULL);
    + portNumBits serverPortNum() const { return ntohs(fServerPort.num()); }
    # HandlerServerForREGISTERCommand(UsageEnvironment& env, onRTSPClientCreationFunc* creationFunc, int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase, int verbosityLevel, char const* applicationName);
    # virtual ~HandlerServerForREGISTERCommand();
    # virtual RTSPClient* createNewRTSPClient(char const* rtspURL, int verbosityLevel, char const* applicationName,
        int socketNumToServer);
    # virtual char const* allowedCommandNames(); // we support "OPTIONS" and "REGISTER" only
    # virtual Boolean weImplementREGISTER(char const* proxyURLSuffix, char*& responseStr); // redefined to return True
    # virtual void implementCmd_REGISTER(char const* url, char const* urlSuffix, int socketToRemoteServer,
        Boolean deliverViaTCP, char const* proxyURLSuffix);
    - onRTSPClientCreationFunc* fCreationFunc;
    - int fVerbosityLevel;
    - char* fApplicationName;
}
Medium <|.. RTSPClient
RTSPClient *-- RequestQueue
RTSPClient *-- RequestRecord
RTSPClient <|-- ProxyRTSPClient
Medium <|.. ServerMediaSession
Medium <|.. ServerMediaSubsession
ServerMediaSubsessionIterator <--ServerMediaSubsession
ServerMediaSession <|-- ProxyServerMediaSession
FramedSource <|.. FramedFilter
FramedFilter <|-- PresentationTimeSubsessionNormalizer
Medium <|-- PresentationTimeSessionNormalizer
ServerMediaSubsession <|-- OnDemandServerMediaSubsession
Destinations <-- OnDemandServerMediaSubsession
Destinations <-- StreamState
StreamState <-- OnDemandServerMediaSubsession
OnDemandServerMediaSubsession <|-- ProxyServerMediaSubsession
RTSPServer <|-- HandlerServerForREGISTERCommand


@enduml