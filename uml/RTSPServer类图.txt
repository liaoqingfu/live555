@startuml

class Medium {
    + static Boolean lookupByName(UsageEnvironment& env, char const* mediumName, Medium*& resultMedium);
    + static void close(UsageEnvironment& env, char const* mediumName);
    + static void close(Medium* medium); // alternative close() method using ptrs
    + UsageEnvironment& envir() const { return fEnviron; }
    + char const* name() const { return fMediumName; }
    + virtual Boolean isSource() const;
    + virtual Boolean isSink() const;
    + virtual Boolean isRTCPInstance() const;
    + virtual Boolean isRTSPClient() const;
    + virtual Boolean isRTSPServer() const;
    + virtual Boolean isMediaSession() const;
    + virtual Boolean isServerMediaSession() const;
    + virtual Boolean isDarwinInjector() const;
    # friend class MediaLookupTable;
    # Medium(UsageEnvironment& env);
    # virtual ~Medium();
    # TaskToken& nextTask();
    - UsageEnvironment& fEnviron;
    - char fMediumName[mediumNameMaxLen];
    - TaskToken fNextTask;
}


class GenericMediaServer {
    + void addServerMediaSession(ServerMediaSession* serverMediaSession);
    + virtual ServerMediaSession*
    + lookupServerMediaSession(char const* streamName, Boolean isFirstLookupInSession = True);
    + void removeServerMediaSession(ServerMediaSession* serverMediaSession);
    + void removeServerMediaSession(char const* streamName);
    + void closeAllClientSessionsForServerMediaSession(ServerMediaSession* serverMediaSession);
    + void closeAllClientSessionsForServerMediaSession(char const* streamName);
    + void deleteServerMediaSession(ServerMediaSession* serverMediaSession);
    + void deleteServerMediaSession(char const* streamName);
    # GenericMediaServer(UsageEnvironment& env, int ourSocket, Port ourPort);
    # virtual ~GenericMediaServer();
    # static int setUpOurSocket(UsageEnvironment& env, Port& ourPort);
    # static void incomingConnectionHandler(void*, int /*mask*/);
    # void incomingConnectionHandler();
    # void incomingConnectionHandlerOnSocket(int serverSocket);
    # virtual ClientConnection*
    # createNewClientConnection(int clientSocket, struct sockaddr_in clientAddr) = 0;
    # int fServerSocket;
    # Port fServerPort;
    # HashTable* fServerMediaSessions;
    # HashTable* fClientConnections;
    # HashTable* fClientSessions;
}


class ClientConnection {
    # ClientConnection(GenericMediaServer& ourServer, int clientSocket, struct sockaddr_in clientAddr);
    # virtual ~ClientConnection();
    # UsageEnvironment& envir() { return fOurServer.envir(); }
    # void closeSockets();
    # static void incomingRequestHandler(void*, int /*mask*/);
    # void incomingRequestHandler();
    # virtual void handleRequestBytes(int newBytesRead) = 0;
    # void resetRequestBuffer();
    # friend class GenericMediaServer;
    # GenericMediaServer& fOurServer;
    # int fOurSocket;
    # struct sockaddr_in fClientAddr;
    # unsigned char fRequestBuffer[REQUEST_BUFFER_SIZE];
    # unsigned char fResponseBuffer[RESPONSE_BUFFER_SIZE];
    # unsigned fRequestBytesAlreadySeen, fRequestBufferBytesLeft;
}


class ClientSession {
    + ClientSession(GenericMediaServer& ourServer, u_int32_t sessionId);
    + virtual ~ClientSession();
    + UsageEnvironment& envir() { return fOurServer.envir(); }

    # friend class GenericMediaServer;
    # GenericMediaServer& fOurServer;
    # u_int32_t fOurSessionId;
    # ServerMediaSession* fOurServerMediaSession;
}


class RTSPServer {
    + static RTSPServer* createNew(UsageEnvironment& env, Port ourPort = 554,
    +     UserAuthenticationDatabase* authDatabase = NULL,
    +     unsigned reclamationTestSeconds = 65);
    + static Boolean lookupByName(UsageEnvironment& env, char const* name,
    +     RTSPServer*& resultServer);
    + typedef void(responseHandlerForREGISTER)(RTSPServer* rtspServer, unsigned requestId, int resultCode, char* resultString);
    + unsigned registerStream(ServerMediaSession* serverMediaSession,
    +     char const* remoteClientNameOrAddress, portNumBits remoteClientPortNum,
    +     responseHandlerForREGISTER* responseHandler,
    +     char const* username = NULL, char const* password = NULL,
    +     Boolean receiveOurStreamViaTCP = False,
    +     char const* proxyURLSuffix = NULL);
    + char* rtspURL(ServerMediaSession const* serverMediaSession, int clientSocket = -1) const;
    + char* rtspURLPrefix(int clientSocket = -1) const;
    + UserAuthenticationDatabase* setAuthenticationDatabase(UserAuthenticationDatabase* newDB);
    + void disableStreamingRTPOverTCP();
    + Boolean setUpTunnelingOverHTTP(Port httpPort);
    + portNumBits httpServerPortNum() const; // in host byte order.  (Returns 0 if not present.)
    # RTSPServer(UsageEnvironment& env,
          int ourSocket, Port ourPort,
          UserAuthenticationDatabase* authDatabase,
          unsigned reclamationTestSeconds);
    # virtual ~RTSPServer();
    # virtual char const* allowedCommandNames();
    # virtual Boolean weImplementREGISTER(char const* proxyURLSuffix, char*& responseStr);
    # virtual void implementCmd_REGISTER(char const* url, char const* urlSuffix, int socketToRemoteServer,
          Boolean deliverViaTCP, char const* proxyURLSuffix);
    # virtual UserAuthenticationDatabase* getAuthenticationDatabaseForCommand(char const* cmdName);
    # virtual Boolean specialClientAccessCheck(int clientSocket, struct sockaddr_in& clientAddr,
          char const* urlSuffix);
    # virtual Boolean specialClientUserAccessCheck(int clientSocket, struct sockaddr_in& clientAddr,
        char const* urlSuffix, char const* username);
    - virtual Boolean isRTSPServer() const;
    # virtual ClientConnection* createNewClientConnection(int clientSocket, struct sockaddr_in clientAddr);
    # virtual ClientSession* createNewClientSession(u_int32_t sessionId);
    - static void incomingConnectionHandlerHTTP(void*, int /*mask*/);
    - void incomingConnectionHandlerHTTP();
    - void noteTCPStreamingOnSocket(int socketNum, RTSPClientSession* clientSession, unsigned trackNum);
    - void unnoteTCPStreamingOnSocket(int socketNum, RTSPClientSession* clientSession, unsigned trackNum);
    - void stopTCPStreamingOnSocket(int socketNum);
    - friend class RTSPClientConnection;
    - friend class RTSPClientSession;
    - friend class ServerMediaSessionIterator;
    - friend class RegisterRequestRecord;
    - int fHTTPServerSocket;
    - Port fHTTPServerPort; 
    - HashTable* fClientConnectionsForHTTPTunneling;
    - HashTable* fTCPStreamingDatabase;
    - HashTable* fPendingRegisterRequests;
    - unsigned fRegisterRequestCounter;
    - UserAuthenticationDatabase* fAuthDB;
    - unsigned fReclamationTestSeconds;
    - Boolean fAllowStreamingRTPOverTCP;
}


class RTSPServerWithREGISTERProxying {
    + static RTSPServerWithREGISTERProxying* createNew(UsageEnvironment& env, Port ourPort = 554,
        UserAuthenticationDatabase* authDatabase = NULL,
        UserAuthenticationDatabase* authDatabaseForREGISTER = NULL,
        unsigned reclamationTestSeconds = 65,
        Boolean streamRTPOverTCP = False,
        int verbosityLevelForProxying = 0);

    # RTSPServerWithREGISTERProxying(UsageEnvironment& env, int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase, UserAuthenticationDatabase* authDatabaseForREGISTER,
        unsigned reclamationTestSeconds,
        Boolean streamRTPOverTCP, int verbosityLevelForProxying);
    # virtual ~RTSPServerWithREGISTERProxying();
    # virtual char const* allowedCommandNames();
    # virtual Boolean weImplementREGISTER(char const* proxyURLSuffix, char*& responseStr);
    # virtual void implementCmd_REGISTER(char const* url, char const* urlSuffix, int socketToRemoteServer,
        Boolean deliverViaTCP, char const* proxyURLSuffix);
    # virtual UserAuthenticationDatabase* getAuthenticationDatabaseForCommand(char const* cmdName);
    - Boolean fStreamRTPOverTCP;
    - int fVerbosityLevelForProxying;
    - unsigned fRegisteredProxyCounter;
    - char* fAllowedCommandNames;
    - UserAuthenticationDatabase* fAuthDBForREGISTER;
}


class RTSPClientConnection {
    # virtual void handleRequestBytes(int newBytesRead);
    # RTSPClientConnection(RTSPServer& ourServer, int clientSocket, struct sockaddr_in clientAddr);
    # virtual ~RTSPClientConnection();
    # friend class RTSPServer;
    # virtual void handleCmd_OPTIONS();
    # virtual void handleCmd_GET_PARAMETER(char const* fullRequestStr);
    # virtual void handleCmd_SET_PARAMETER(char const* fullRequestStr);
    # virtual void handleCmd_DESCRIBE(char const* urlPreSuffix, char const* urlSuffix, char const* fullRequestStr);
    # virtual void handleCmd_REGISTER(char const* url, char const* urlSuffix, char const* fullRequestStr,
    #     Boolean reuseConnection, Boolean deliverViaTCP, char const* proxyURLSuffix);
    # virtual void handleCmd_bad();
    # virtual void handleCmd_notSupported();
    # virtual void handleCmd_notFound();
    # virtual void handleCmd_sessionNotFound();
    # virtual void handleCmd_unsupportedTransport();
    # virtual Boolean parseHTTPRequestString(char* resultCmdName, unsigned resultCmdNameMaxSize,
    #     char* urlSuffix, unsigned urlSuffixMaxSize,
    #     char* sessionCookie, unsigned sessionCookieMaxSize,
    #     char* acceptStr, unsigned acceptStrMaxSize);
    # virtual void handleHTTPCmd_notSupported();
    # virtual void handleHTTPCmd_notFound();
    # virtual void handleHTTPCmd_OPTIONS();
    # virtual void handleHTTPCmd_TunnelingGET(char const* sessionCookie);
    # virtual Boolean handleHTTPCmd_TunnelingPOST(char const* sessionCookie, unsigned char const* extraData, unsigned extraDataSize);
    # virtual void handleHTTPCmd_StreamingGET(char const* urlSuffix, char const* fullRequestStr);
    # void resetRequestBuffer();
    # void closeSockets();
    # static void handleAlternativeRequestByte(void*, u_int8_t requestByte);
    # void handleAlternativeRequestByte1(u_int8_t requestByte);
    # Boolean authenticationOK(char const* cmdName, char const* urlSuffix, char const* fullRequestStr);
    # void changeClientInputSocket(int newSocketNum, unsigned char const* extraData, unsigned extraDataSize);
    # static void continueHandlingREGISTER(ParamsForREGISTER* params);
    # virtual void continueHandlingREGISTER1(ParamsForREGISTER* params);
    # void setRTSPResponse(char const* responseStr);
    # void setRTSPResponse(char const* responseStr, u_int32_t sessionId);
    # void setRTSPResponse(char const* responseStr, char const* contentStr);
    # void setRTSPResponse(char const* responseStr, u_int32_t sessionId, char const* contentStr);
    # RTSPServer& fOurRTSPServer;
    # int& fClientInputSocket;
    # int fClientOutputSocket;
    # Boolean fIsActive;
    # unsigned char* fLastCRLF;
    # unsigned fRecursionCount;
    # char const* fCurrentCSeq;
    # Authenticator fCurrentAuthenticator;
    # char* fOurSessionCookie;
    # unsigned fBase64RemainderCount;
}


class RTSPClientSession {
    # RTSPClientSession(RTSPServer& ourServer, u_int32_t sessionId);
    # virtual ~RTSPClientSession();
    # friend class RTSPServer;
    # virtual void handleCmd_SETUP(RTSPClientConnection* ourClientConnection,
         char const* urlPreSuffix, char const* urlSuffix, char const* fullRequestStr);
    # virtual void handleCmd_withinSession(RTSPClientConnection* ourClientConnection,
         char const* cmdName,
         char const* urlPreSuffix, char const* urlSuffix,
         char const* fullRequestStr);
    # virtual void handleCmd_TEARDOWN(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession);
    # virtual void handleCmd_PLAY(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession, char const* fullRequestStr);
    # virtual void handleCmd_PAUSE(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession);
    # virtual void handleCmd_GET_PARAMETER(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession, char const* fullRequestStr);
    # virtual void handleCmd_SET_PARAMETER(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession, char const* fullRequestStr);
    # void deleteStreamByTrack(unsigned trackNum);
    # void reclaimStreamStates();
    # Boolean isMulticast();
    # void noteLiveness();
    # static void noteClientLiveness(RTSPClientSession* clientSession);
    # static void livenessTimeoutTask(RTSPClientSession* clientSession);
    # void setRTSPResponse(RTSPClientConnection* ourClientConnection, char const* responseStr);
    # void setRTSPResponse(RTSPClientConnection* ourClientConnection, char const* responseStr, u_int32_t sessionId);
    # void setRTSPResponse(RTSPClientConnection* ourClientConnection, char const* responseStr, char const* contentStr);
    # RTSPServer& fOurRTSPServer;
    # Boolean fIsMulticast, fStreamAfterSETUP;
    # unsigned char fTCPStreamIdCount;
    # Boolean usesTCPTransport() const;
    # TaskToken fLivenessCheckTask;
    # unsigned fNumStreamStates;
}


class streamState {
    ServerMediaSubsession* subsession;
    int tcpSocketNum;
    void* streamToken;
}


class ServerMediaSessionIterator {
    + ServerMediaSessionIterator(RTSPServer& server);
    + virtual ~ServerMediaSessionIterator();
    + ServerMediaSession* next();
    - HashTable::Iterator* fOurIterator;
}


class ParamsForREGISTER {
    + ParamsForREGISTER(RTSPClientConnection* ourConnection, char const* url, char const* urlSuffix,
        Boolean reuseConnection, Boolean deliverViaTCP, char const* proxyURLSuffix);
    + virtual ~ParamsForREGISTER();
    - friend class RTSPClientConnection;
    - RTSPClientConnection* fOurConnection;
    - char* fURL;
    - char* fURLSuffix;
    - Boolean fReuseConnection, fDeliverViaTCP;
    - char* fProxyURLSuffix;
}


class RTSPServerSupportingHTTPStreaming {
    + static RTSPServerSupportingHTTPStreaming* createNew(UsageEnvironment& env, Port rtspPort = 554,
        UserAuthenticationDatabase* authDatabase = NULL,
        unsigned reclamationTestSeconds = 65);

    + Boolean setHTTPPort(Port httpPort) { return setUpTunnelingOverHTTP(httpPort); }
    # RTSPServerSupportingHTTPStreaming(UsageEnvironment& env,
        int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase,
        unsigned reclamationTestSeconds);
    # virtual ~RTSPServerSupportingHTTPStreaming();
    # virtual RTSPClientConnection* createNewClientConnection(int clientSocket, struct sockaddr_in clientAddr);
}


class RTSPClientConnectionSupportingHTTPStreaming {
    + RTSPClientConnectionSupportingHTTPStreaming(RTSPServer& ourServer, int clientSocket, struct sockaddr_in clientAddr);
    + virtual ~RTSPClientConnectionSupportingHTTPStreaming();
    # virtual void handleHTTPCmd_StreamingGET(char const* urlSuffix, char const* fullRequestStr);
    # static void afterStreaming(void* clientData);
    - u_int32_t fClientSessionId;
    - FramedSource* fStreamSource;
    - ByteStreamMemoryBufferSource* fPlaylistSource;
    - TCPStreamSink* fTCPSink;
}


class DynamicRTSPServer {
    + static DynamicRTSPServer* createNew(UsageEnvironment& env, Port ourPort,
        UserAuthenticationDatabase* authDatabase,
        unsigned reclamationTestSeconds = 65);
    # DynamicRTSPServer(UsageEnvironment& env, int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase, unsigned reclamationTestSeconds);
    # virtual ~DynamicRTSPServer();
    # virtual ServerMediaSession*
    # lookupServerMediaSession(char const* streamName, Boolean isFirstLookupInSession);
}


Medium <|.. GenericMediaServer
GenericMediaServer +--> ClientConnection
GenericMediaServer +--> ClientSession
ClientConnection --> GenericMediaServer
ClientSession --> GenericMediaServer
GenericMediaServer <|.. RTSPServer
RTSPServer --> RTSPClientConnection
RTSPServer --> RTSPClientSession
RTSPServer --> ServerMediaSessionIterator
RTSPServer --> RegisterRequestRecord
RTSPServer <|-- RTSPServerWithREGISTERProxying
RTSPServer +--> RTSPClientConnection
RTSPClientConnection --> RTSPServer
ClientConnection <|-- RTSPClientConnection
RTSPServer +--> RTSPClientSession
ClientSession <|-- RTSPClientSession
RTSPClientSession +--> streamState
RTSPServer +--> ServerMediaSessionIterator
RTSPClientConnection +--> ParamsForREGISTER
ParamsForREGISTER --> RTSPClientConnection
RTSPServer <|-- RTSPServerSupportingHTTPStreaming
RTSPServerSupportingHTTPStreaming +--> RTSPClientConnectionSupportingHTTPStreaming
RTSPClientConnection <|-- RTSPClientConnectionSupportingHTTPStreaming
RTSPServerSupportingHTTPStreaming <|-- DynamicRTSPServer

@enduml