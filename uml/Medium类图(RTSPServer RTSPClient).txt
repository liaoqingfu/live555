@startuml

class Medium {
    + static Boolean lookupByName(UsageEnvironment& env, char const* mediumName, Medium*& resultMedium);
    + static void close(UsageEnvironment& env, char const* mediumName);
    + static void close(Medium* medium);
    + UsageEnvironment& envir() const;
    + char const* name() const;
    + virtual Boolean isSource() const;
    + virtual Boolean isSink() const;
    + virtual Boolean isRTCPInstance() const;
    + virtual Boolean isRTSPClient() const;
    + virtual Boolean isRTSPServer() const;
    + virtual Boolean isMediaSession() const;
    + virtual Boolean isServerMediaSession() const;
    + virtual Boolean isDarwinInjector() const;
    # friend class MediaLookupTable;
    # Medium(UsageEnvironment& env);
    # virtual ~Medium();
    # TaskToken& nextTask();
    - UsageEnvironment& fEnviron;
    - char fMediumName[mediumNameMaxLen];
    - TaskToken fNextTask;
}


class GenericMediaServer {
    + void addServerMediaSession(ServerMediaSession* serverMediaSession);
    + virtual ServerMediaSession* lookupServerMediaSession(char const* streamName, Boolean isFirstLookupInSession = True);
    + void removeServerMediaSession(ServerMediaSession* serverMediaSession);
    + void removeServerMediaSession(char const* streamName);
    + void closeAllClientSessionsForServerMediaSession(ServerMediaSession* serverMediaSession);
    + void closeAllClientSessionsForServerMediaSession(char const* streamName);
    + void deleteServerMediaSession(ServerMediaSession* serverMediaSession);
    + void deleteServerMediaSession(char const* streamName);
    # GenericMediaServer(UsageEnvironment& env, int ourSocket, Port ourPort);
    # virtual ~GenericMediaServer();
    # static int setUpOurSocket(UsageEnvironment& env, Port& ourPort);
    # static void incomingConnectionHandler(void*, int /*mask*/);
    # void incomingConnectionHandler();
    # void incomingConnectionHandlerOnSocket(int serverSocket);
    # virtual ClientConnection*
    # createNewClientConnection(int clientSocket, struct sockaddr_in clientAddr) = 0;
    # int fServerSocket;
    # Port fServerPort;
    # HashTable* fServerMediaSessions;
    # HashTable* fClientConnections;
    # HashTable* fClientSessions;
}
GenericMediaServer ..|> Medium


class ClientConnection {
    # ClientConnection(GenericMediaServer& ourServer, int clientSocket, struct sockaddr_in clientAddr);
    # virtual ~ClientConnection();
    # UsageEnvironment& envir() { return fOurServer.envir(); }
    # void closeSockets();
    # static void incomingRequestHandler(void*, int /*mask*/);
    # void incomingRequestHandler();
    # virtual void handleRequestBytes(int newBytesRead) = 0;
    # void resetRequestBuffer();
    # friend class GenericMediaServer;
    # GenericMediaServer& fOurServer;
    # int fOurSocket;
    # struct sockaddr_in fClientAddr;
    # unsigned char fRequestBuffer[REQUEST_BUFFER_SIZE];
    # unsigned char fResponseBuffer[RESPONSE_BUFFER_SIZE];
    # unsigned fRequestBytesAlreadySeen, fRequestBufferBytesLeft;
}
ClientConnection <--+ GenericMediaServer
ClientConnection --> GenericMediaServer


class ClientSession {
    + ClientSession(GenericMediaServer& ourServer, u_int32_t sessionId);
    + virtual ~ClientSession();
    + UsageEnvironment& envir();

    # friend class GenericMediaServer;
    # GenericMediaServer& fOurServer;
    # u_int32_t fOurSessionId;
    # ServerMediaSession* fOurServerMediaSession;
}
ClientSession <--+ GenericMediaServer
ClientSession --> GenericMediaServer


class RTSPServer {
    + static RTSPServer* createNew(UsageEnvironment& env, Port ourPort = 554,
    +     UserAuthenticationDatabase* authDatabase = NULL,
    +     unsigned reclamationTestSeconds = 65);
    + static Boolean lookupByName(UsageEnvironment& env, char const* name,
    +     RTSPServer*& resultServer);
    + typedef void(responseHandlerForREGISTER)(RTSPServer* rtspServer, unsigned requestId, int resultCode, char* resultString);
    + unsigned registerStream(ServerMediaSession* serverMediaSession,
    +     char const* remoteClientNameOrAddress, portNumBits remoteClientPortNum,
    +     responseHandlerForREGISTER* responseHandler,
    +     char const* username = NULL, char const* password = NULL,
    +     Boolean receiveOurStreamViaTCP = False,
    +     char const* proxyURLSuffix = NULL);
    + char* rtspURL(ServerMediaSession const* serverMediaSession, int clientSocket = -1) const;
    + char* rtspURLPrefix(int clientSocket = -1) const;
    + UserAuthenticationDatabase* setAuthenticationDatabase(UserAuthenticationDatabase* newDB);
    + void disableStreamingRTPOverTCP();
    + Boolean setUpTunnelingOverHTTP(Port httpPort);
    + portNumBits httpServerPortNum() const; // in host byte order.  (Returns 0 if not present.)
    # RTSPServer(UsageEnvironment& env,
          int ourSocket, Port ourPort,
          UserAuthenticationDatabase* authDatabase,
          unsigned reclamationTestSeconds);
    # virtual ~RTSPServer();
    # virtual char const* allowedCommandNames();
    # virtual Boolean weImplementREGISTER(char const* proxyURLSuffix, char*& responseStr);
    # virtual void implementCmd_REGISTER(char const* url, char const* urlSuffix, int socketToRemoteServer,
          Boolean deliverViaTCP, char const* proxyURLSuffix);
    # virtual UserAuthenticationDatabase* getAuthenticationDatabaseForCommand(char const* cmdName);
    # virtual Boolean specialClientAccessCheck(int clientSocket, struct sockaddr_in& clientAddr,
          char const* urlSuffix);
    # virtual Boolean specialClientUserAccessCheck(int clientSocket, struct sockaddr_in& clientAddr,
        char const* urlSuffix, char const* username);
    - virtual Boolean isRTSPServer() const;
    # virtual ClientConnection* createNewClientConnection(int clientSocket, struct sockaddr_in clientAddr);
    # virtual ClientSession* createNewClientSession(u_int32_t sessionId);
    - static void incomingConnectionHandlerHTTP(void*, int /*mask*/);
    - void incomingConnectionHandlerHTTP();
    - void noteTCPStreamingOnSocket(int socketNum, RTSPClientSession* clientSession, unsigned trackNum);
    - void unnoteTCPStreamingOnSocket(int socketNum, RTSPClientSession* clientSession, unsigned trackNum);
    - void stopTCPStreamingOnSocket(int socketNum);
    - friend class RTSPClientConnection;
    - friend class RTSPClientSession;
    - friend class ServerMediaSessionIterator;
    - friend class RegisterRequestRecord;
    - int fHTTPServerSocket;
    - Port fHTTPServerPort; 
    - HashTable* fClientConnectionsForHTTPTunneling;
    - HashTable* fTCPStreamingDatabase;
    - HashTable* fPendingRegisterRequests;
    - unsigned fRegisterRequestCounter;
    - UserAuthenticationDatabase* fAuthDB;
    - unsigned fReclamationTestSeconds;
    - Boolean fAllowStreamingRTPOverTCP;
}
RTSPServer --|> GenericMediaServer
RTSPServer --> RTSPClientConnection
RTSPServer --> RTSPClientSession
RTSPServer --> ServerMediaSessionIterator
RTSPServer --> RegisterRequestRecord
RTSPServer +--> RTSPClientConnection
RTSPServer +--> RTSPClientSession
RTSPServer +--> ServerMediaSessionIterator


class RegisterRequestRecord {
    + RegisterRequestRecord(RTSPServer& ourServer, unsigned requestId,
        char const* remoteClientNameOrAddress, portNumBits remoteClientPortNum, char const* rtspURLToRegister,
        RTSPServer::responseHandlerForREGISTER* responseHandler, Authenticator* authenticator,
        Boolean requestStreamingViaTCP, char const* proxyURLSuffix);
    + virtual ~RegisterRequestRecord();
    + void handleResponse(int resultCode, char* resultString);
    - RTSPServer& fOurServer;
    - unsigned fRequestId;
    - RTSPServer::responseHandlerForREGISTER* fResponseHandler;
}
RegisterRequestRecord --|> RTSPRegisterSender


class RTSPRegisterSender {
    + static RTSPRegisterSender*
    + createNew(UsageEnvironment& env,
        char const* remoteClientNameOrAddress, portNumBits remoteClientPortNum, char const* rtspURLToRegister,
        RTSPClient::responseHandler* rtspResponseHandler, Authenticator* authenticator = NULL,
        Boolean requestStreamingViaTCP = False, char const* proxyURLSuffix = NULL, Boolean reuseConnection = False,
        int verbosityLevel = 0, char const* applicationName = NULL);
    + void grabConnection(int& sock, struct sockaddr_in& remoteAddress); // so that the socket doesn't get closed when we're deleted
    # RTSPRegisterSender(UsageEnvironment& env,
                char const* remoteClientNameOrAddress, portNumBits remoteClientPortNum, char const* rtspURLToRegister,
                RTSPClient::responseHandler* rtspResponseHandler, Authenticator* authenticator,
                Boolean requestStreamingViaTCP, char const* proxyURLSuffix, Boolean reuseConnection,
                int verbosityLevel, char const* applicationName);
    # virtual ~RTSPRegisterSender();
    # virtual Boolean setRequestFields(RequestRecord* request,
                                    char*& cmdURL, Boolean& cmdURLWasAllocated,
                                    char const*& protocolStr,
                                    char*& extraHeaders, Boolean& extraHeadersWereAllocated);
    - portNumBits fRemoteClientPortNum;
}
RTSPRegisterSender --|> RTSPClient
RTSPRegisterSender +--> RequestRecord_REGISTER


class RequestRecord_REGISTER {
    + RequestRecord_REGISTER(unsigned cseq, RTSPClient::responseHandler* rtspResponseHandler, char const* rtspURLToRegister,
                  Boolean reuseConnection, Boolean requestStreamingViaTCP, char const* proxyURLSuffix);
    + virtual ~RequestRecord_REGISTER();
    + char const* rtspURLToRegister() const { return fRTSPURLToRegister; }
    + Boolean reuseConnection() const { return fReuseConnection; }
    + Boolean requestStreamingViaTCP() const { return fRequestStreamingViaTCP; }
    + char const* proxyURLSuffix() const { return fProxyURLSuffix; }
    - char* fRTSPURLToRegister;
    - Boolean fReuseConnection, fRequestStreamingViaTCP;
    - char* fProxyURLSuffix;
}
RequestRecord_REGISTER --|> RequestRecord


class RTSPServerWithREGISTERProxying {
    + static RTSPServerWithREGISTERProxying* createNew(UsageEnvironment& env, Port ourPort = 554,
        UserAuthenticationDatabase* authDatabase = NULL,
        UserAuthenticationDatabase* authDatabaseForREGISTER = NULL,
        unsigned reclamationTestSeconds = 65,
        Boolean streamRTPOverTCP = False,
        int verbosityLevelForProxying = 0);

    # RTSPServerWithREGISTERProxying(UsageEnvironment& env, int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase, UserAuthenticationDatabase* authDatabaseForREGISTER,
        unsigned reclamationTestSeconds,
        Boolean streamRTPOverTCP, int verbosityLevelForProxying);
    # virtual ~RTSPServerWithREGISTERProxying();
    # virtual char const* allowedCommandNames();
    # virtual Boolean weImplementREGISTER(char const* proxyURLSuffix, char*& responseStr);
    # virtual void implementCmd_REGISTER(char const* url, char const* urlSuffix, int socketToRemoteServer,
        Boolean deliverViaTCP, char const* proxyURLSuffix);
    # virtual UserAuthenticationDatabase* getAuthenticationDatabaseForCommand(char const* cmdName);
    - Boolean fStreamRTPOverTCP;
    - int fVerbosityLevelForProxying;
    - unsigned fRegisteredProxyCounter;
    - char* fAllowedCommandNames;
    - UserAuthenticationDatabase* fAuthDBForREGISTER;
}
RTSPServerWithREGISTERProxying --|> RTSPServer


class RTSPClientConnection {
    # virtual void handleRequestBytes(int newBytesRead);
    # RTSPClientConnection(RTSPServer& ourServer, int clientSocket, struct sockaddr_in clientAddr);
    # virtual ~RTSPClientConnection();
    # friend class RTSPServer;
    # virtual void handleCmd_OPTIONS();
    # virtual void handleCmd_GET_PARAMETER(char const* fullRequestStr);
    # virtual void handleCmd_SET_PARAMETER(char const* fullRequestStr);
    # virtual void handleCmd_DESCRIBE(char const* urlPreSuffix, char const* urlSuffix, char const* fullRequestStr);
    # virtual void handleCmd_REGISTER(char const* url, char const* urlSuffix, char const* fullRequestStr,
    #     Boolean reuseConnection, Boolean deliverViaTCP, char const* proxyURLSuffix);
    # virtual void handleCmd_bad();
    # virtual void handleCmd_notSupported();
    # virtual void handleCmd_notFound();
    # virtual void handleCmd_sessionNotFound();
    # virtual void handleCmd_unsupportedTransport();
    # virtual Boolean parseHTTPRequestString(char* resultCmdName, unsigned resultCmdNameMaxSize,
    #     char* urlSuffix, unsigned urlSuffixMaxSize,
    #     char* sessionCookie, unsigned sessionCookieMaxSize,
    #     char* acceptStr, unsigned acceptStrMaxSize);
    # virtual void handleHTTPCmd_notSupported();
    # virtual void handleHTTPCmd_notFound();
    # virtual void handleHTTPCmd_OPTIONS();
    # virtual void handleHTTPCmd_TunnelingGET(char const* sessionCookie);
    # virtual Boolean handleHTTPCmd_TunnelingPOST(char const* sessionCookie, unsigned char const* extraData, unsigned extraDataSize);
    # virtual void handleHTTPCmd_StreamingGET(char const* urlSuffix, char const* fullRequestStr);
    # void resetRequestBuffer();
    # void closeSockets();
    # static void handleAlternativeRequestByte(void*, u_int8_t requestByte);
    # void handleAlternativeRequestByte1(u_int8_t requestByte);
    # Boolean authenticationOK(char const* cmdName, char const* urlSuffix, char const* fullRequestStr);
    # void changeClientInputSocket(int newSocketNum, unsigned char const* extraData, unsigned extraDataSize);
    # static void continueHandlingREGISTER(ParamsForREGISTER* params);
    # virtual void continueHandlingREGISTER1(ParamsForREGISTER* params);
    # void setRTSPResponse(char const* responseStr);
    # void setRTSPResponse(char const* responseStr, u_int32_t sessionId);
    # void setRTSPResponse(char const* responseStr, char const* contentStr);
    # void setRTSPResponse(char const* responseStr, u_int32_t sessionId, char const* contentStr);
    # RTSPServer& fOurRTSPServer;
    # int& fClientInputSocket;
    # int fClientOutputSocket;
    # Boolean fIsActive;
    # unsigned char* fLastCRLF;
    # unsigned fRecursionCount;
    # char const* fCurrentCSeq;
    # Authenticator fCurrentAuthenticator;
    # char* fOurSessionCookie;
    # unsigned fBase64RemainderCount;
}
RTSPClientConnection --> ClientConnection
RTSPClientConnection --> RTSPServer
RTSPClientConnection +--> ParamsForREGISTER


class RTSPClientSession {
    # RTSPClientSession(RTSPServer& ourServer, u_int32_t sessionId);
    # virtual ~RTSPClientSession();
    # friend class RTSPServer;
    # virtual void handleCmd_SETUP(RTSPClientConnection* ourClientConnection,
         char const* urlPreSuffix, char const* urlSuffix, char const* fullRequestStr);
    # virtual void handleCmd_withinSession(RTSPClientConnection* ourClientConnection,
         char const* cmdName,
         char const* urlPreSuffix, char const* urlSuffix,
         char const* fullRequestStr);
    # virtual void handleCmd_TEARDOWN(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession);
    # virtual void handleCmd_PLAY(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession, char const* fullRequestStr);
    # virtual void handleCmd_PAUSE(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession);
    # virtual void handleCmd_GET_PARAMETER(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession, char const* fullRequestStr);
    # virtual void handleCmd_SET_PARAMETER(RTSPClientConnection* ourClientConnection,
         ServerMediaSubsession* subsession, char const* fullRequestStr);
    # void deleteStreamByTrack(unsigned trackNum);
    # void reclaimStreamStates();
    # Boolean isMulticast();
    # void noteLiveness();
    # static void noteClientLiveness(RTSPClientSession* clientSession);
    # static void livenessTimeoutTask(RTSPClientSession* clientSession);
    # void setRTSPResponse(RTSPClientConnection* ourClientConnection, char const* responseStr);
    # void setRTSPResponse(RTSPClientConnection* ourClientConnection, char const* responseStr, u_int32_t sessionId);
    # void setRTSPResponse(RTSPClientConnection* ourClientConnection, char const* responseStr, char const* contentStr);
    # RTSPServer& fOurRTSPServer;
    # Boolean fIsMulticast, fStreamAfterSETUP;
    # unsigned char fTCPStreamIdCount;
    # Boolean usesTCPTransport() const;
    # TaskToken fLivenessCheckTask;
    # unsigned fNumStreamStates;
}
RTSPClientSession --> ClientSession
RTSPClientSession --> RTSPServer


class streamState {
    ServerMediaSubsession* subsession;
    int tcpSocketNum;
    void* streamToken;
}
RTSPClientSession +--> streamState


class ServerMediaSessionIterator {
    + ServerMediaSessionIterator(RTSPServer& server);
    + virtual ~ServerMediaSessionIterator();
    + ServerMediaSession* next();
    - HashTable::Iterator* fOurIterator;
}


class ParamsForREGISTER {
    + ParamsForREGISTER(RTSPClientConnection* ourConnection, char const* url, char const* urlSuffix,
        Boolean reuseConnection, Boolean deliverViaTCP, char const* proxyURLSuffix);
    + virtual ~ParamsForREGISTER();
    - friend class RTSPClientConnection;
    - RTSPClientConnection* fOurConnection;
    - char* fURL;
    - char* fURLSuffix;
    - Boolean fReuseConnection, fDeliverViaTCP;
    - char* fProxyURLSuffix;
}
ParamsForREGISTER --> RTSPClientConnection


class RTSPServerSupportingHTTPStreaming {
    + static RTSPServerSupportingHTTPStreaming* createNew(UsageEnvironment& env, Port rtspPort = 554,
        UserAuthenticationDatabase* authDatabase = NULL,
        unsigned reclamationTestSeconds = 65);
    + Boolean setHTTPPort(Port httpPort) { return setUpTunnelingOverHTTP(httpPort); }
    # RTSPServerSupportingHTTPStreaming(UsageEnvironment& env,
        int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase,
        unsigned reclamationTestSeconds);
    # virtual ~RTSPServerSupportingHTTPStreaming();
    # virtual RTSPClientConnection* createNewClientConnection(int clientSocket, struct sockaddr_in clientAddr);
}
RTSPServerSupportingHTTPStreaming --|> RTSPServer
RTSPServerSupportingHTTPStreaming +--> RTSPClientConnectionSupportingHTTPStreaming


class RTSPClientConnectionSupportingHTTPStreaming {
    + RTSPClientConnectionSupportingHTTPStreaming(RTSPServer& ourServer, int clientSocket, struct sockaddr_in clientAddr);
    + virtual ~RTSPClientConnectionSupportingHTTPStreaming();
    # virtual void handleHTTPCmd_StreamingGET(char const* urlSuffix, char const* fullRequestStr);
    # static void afterStreaming(void* clientData);
    - u_int32_t fClientSessionId;
    - FramedSource* fStreamSource;
    - ByteStreamMemoryBufferSource* fPlaylistSource;
    - TCPStreamSink* fTCPSink;
}
RTSPClientConnectionSupportingHTTPStreaming --|> RTSPClientConnection


class DynamicRTSPServer {
    + static DynamicRTSPServer* createNew(UsageEnvironment& env, Port ourPort,
        UserAuthenticationDatabase* authDatabase,
        unsigned reclamationTestSeconds = 65);
    # DynamicRTSPServer(UsageEnvironment& env, int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase, unsigned reclamationTestSeconds);
    # virtual ~DynamicRTSPServer();
    # virtual ServerMediaSession*
    # lookupServerMediaSession(char const* streamName, Boolean isFirstLookupInSession);
}
DynamicRTSPServer --|> RTSPServerSupportingHTTPStreaming


class RTSPClient {
    + static RTSPClient* createNew(UsageEnvironment& env, char const* rtspURL,
          int verbosityLevel = 0,
          char const* applicationName = NULL,
          portNumBits tunnelOverHTTPPortNum = 0,
          int socketNumToServer = -1);
    + typedef void(responseHandler)(RTSPClient* rtspClient,
          int resultCode, char* resultString);
    + unsigned sendDescribeCommand(responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendOptionsCommand(responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendAnnounceCommand(char const* sdpDescription, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendSetupCommand(MediaSubsession& subsession, responseHandler* responseHandler,
          Boolean streamOutgoing = False,
          Boolean streamUsingTCP = False,
          Boolean forceMulticastOnUnspecified = False,
          Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSession& session, responseHandler* responseHandler,
    +     double start = 0.0f, double end = -1.0f, float scale = 1.0f,
    +     Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSubsession& subsession, responseHandler* responseHandler,
          double start = 0.0f, double end = -1.0f, float scale = 1.0f,
          Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSession& session, responseHandler* responseHandler,
          char const* absStartTime, char const* absEndTime = NULL, float scale = 1.0f,
          Authenticator* authenticator = NULL);
    + unsigned sendPlayCommand(MediaSubsession& subsession, responseHandler* responseHandler,
          char const* absStartTime, char const* absEndTime = NULL, float scale = 1.0f,
          Authenticator* authenticator = NULL);
    + unsigned sendPauseCommand(MediaSession& session, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendPauseCommand(MediaSubsession& subsession, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendRecordCommand(MediaSession& session, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendRecordCommand(MediaSubsession& subsession, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendTeardownCommand(MediaSession& session, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendTeardownCommand(MediaSubsession& subsession, responseHandler* responseHandler, Authenticator* authenticator = NULL);
    + unsigned sendSetParameterCommand(MediaSession& session, responseHandler* responseHandler,
          char const* parameterName, char const* parameterValue,
          Authenticator* authenticator = NULL);
    + unsigned sendGetParameterCommand(MediaSession& session, responseHandler* responseHandler, char const* parameterName,
          Authenticator* authenticator = NULL);
    + void sendDummyUDPPackets(MediaSession& session, unsigned numDummyPackets = 2);
    + void sendDummyUDPPackets(MediaSubsession& subsession, unsigned numDummyPackets = 2);
    + void setSpeed(MediaSession& session, float speed = 1.0f);
    + Boolean changeResponseHandler(unsigned cseq, responseHandler* newResponseHandler);
    + int socketNum() const { return fInputSocketNum; }
    + static Boolean lookupByName(UsageEnvironment& env,
          char const* sourceName,
          RTSPClient*& resultClient);
    + static Boolean parseRTSPURL(UsageEnvironment& env, char const* url,
          char*& username, char*& password, NetAddress& address, portNumBits& portNum, char const** urlSuffix = NULL);
    + void setUserAgentString(char const* userAgentName);
    + void disallowBasicAuthentication() { fAllowBasicAuthentication = False; }
    + unsigned sessionTimeoutParameter() const { return fSessionTimeoutParameter; }
    + char const* url() const { return fBaseURL; }
    + static unsigned responseBufferSize;
    # RTSPClient(UsageEnvironment& env, char const* rtspURL,
          int verbosityLevel, char const* applicationName, portNumBits tunnelOverHTTPPortNum, int socketNumToServer);
    # virtual ~RTSPClient();
    # void reset();
    # void setBaseURL(char const* url);
    # int grabSocket(); // allows a subclass to reuse our input socket, so that it won't get closed when we're deleted
    # virtual unsigned sendRequest(RequestRecord* request);
    # virtual Boolean setRequestFields(RequestRecord* request,
        char*& cmdURL, Boolean& cmdURLWasAllocated,
        char const*& protocolStr,
        char*& extraHeaders, Boolean& extraHeadersWereAllocated);
    - virtual Boolean isRTSPClient() const;
    - void resetTCPSockets();
    - void resetResponseBuffer();
    - int openConnection(); // -1: failure; 0: pending; 1: success
    - int connectToServer(int socketNum, portNumBits remotePortNum); // used to implement "openConnection()"; result values are the same
    - char* createAuthenticatorString(char const* cmd, char const* url);
    - char* createBlocksizeString(Boolean streamUsingTCP);
    - void handleRequestError(RequestRecord* request);
    - Boolean parseResponseCode(char const* line, unsigned& responseCode, char const*& responseString);
    - void handleIncomingRequest();
    - static Boolean checkForHeader(char const* line, char const* headerName, unsigned headerNameLength, char const*& headerParams);
    - Boolean parseTransportParams(char const* paramsStr,
          char*& serverAddressStr, portNumBits& serverPortNum,
          unsigned char& rtpChannelId, unsigned char& rtcpChannelId);
    - Boolean parseScaleParam(char const* paramStr, float& scale);
    - Boolean parseSpeedParam(char const* paramStr, float& speed);
    - Boolean parseRTPInfoParams(char const*& paramStr, u_int16_t& seqNum, u_int32_t& timestamp);
    - Boolean handleSETUPResponse(MediaSubsession& subsession, char const* sessionParamsStr, char const* transportParamsStr,
          Boolean streamUsingTCP);
    - Boolean handlePLAYResponse(MediaSession& session, MediaSubsession& subsession,
          char const* scaleParamsStr, const char* speedParamsStr,
          char const* rangeParamsStr, char const* rtpInfoParamsStr);
    - Boolean handleTEARDOWNResponse(MediaSession& session, MediaSubsession& subsession);
    - Boolean handleGET_PARAMETERResponse(char const* parameterName, char*& resultValueString);
    - Boolean handleAuthenticationFailure(char const* wwwAuthenticateParamsStr);
    - Boolean resendCommand(RequestRecord* request);
    - char const* sessionURL(MediaSession const& session) const;
    - static void handleAlternativeRequestByte(void*, u_int8_t requestByte);
    - void handleAlternativeRequestByte1(u_int8_t requestByte);
    - void constructSubsessionURL(MediaSubsession const& subsession,
          char const*& prefix,
          char const*& separator,
          char const*& suffix);
    - Boolean setupHTTPTunneling1(); // send the HTTP "GET"
    - static void responseHandlerForHTTP_GET(RTSPClient* rtspClient, int responseCode, char* responseString);
    - void responseHandlerForHTTP_GET1(int responseCode, char* responseString);
    - Boolean setupHTTPTunneling2(); // send the HTTP "POST"
    - static void connectionHandler(void*, int /*mask*/);
    - void connectionHandler1();
    - static void incomingDataHandler(void*, int /*mask*/);
    - void incomingDataHandler1();
    - void handleResponseBytes(int newBytesRead);
    + u_int16_t desiredMaxIncomingPacketSize;
    # int fVerbosityLevel;
    # unsigned fCSeq;
    # Authenticator fCurrentAuthenticator;
    # Boolean fAllowBasicAuthentication;
    # netAddressBits fServerAddress;
    - portNumBits fTunnelOverHTTPPortNum;
    - char* fUserAgentHeaderStr;
    - unsigned fUserAgentHeaderStrLen;
    - int fInputSocketNum, fOutputSocketNum;
    - char* fBaseURL;
    - unsigned char fTCPStreamIdCount; // used for (optional) RTP/TCP
    - char* fLastSessionId;
    - unsigned fSessionTimeoutParameter; // optionally set in response "Session:" headers
    - char* fResponseBuffer;
    - unsigned fResponseBytesAlreadySeen, fResponseBufferBytesLeft;
    - RequestQueue fRequestsAwaitingConnection, fRequestsAwaitingHTTPTunneling, fRequestsAwaitingResponse;
    - char fSessionCookie[33];
    - unsigned fSessionCookieCounter;
    - Boolean fHTTPTunnelingConnectionIsPending;
}
RTSPClient --|> Medium
RTSPClient +--> RequestQueue
RTSPClient +--> RequestRecord


class HandlerServerForREGISTERCommand {
    + static HandlerServerForREGISTERCommand* createNew(UsageEnvironment& env, onRTSPClientCreationFunc* creationFunc,
        Port ourPort = 0, UserAuthenticationDatabase* authDatabase = NULL,
        int verbosityLevel = 0, char const* applicationName = NULL);
    # HandlerServerForREGISTERCommand(UsageEnvironment& env, onRTSPClientCreationFunc* creationFunc, int ourSocket, Port ourPort,
        UserAuthenticationDatabase* authDatabase, int verbosityLevel, char const* applicationName);
    # virtual ~HandlerServerForREGISTERCommand();
    # virtual RTSPClient* createNewRTSPClient(char const* rtspURL, int verbosityLevel, char const* applicationName,
        int socketNumToServer);
    # virtual char const* allowedCommandNames(); // we support "OPTIONS" and "REGISTER" only
    # virtual Boolean weImplementREGISTER(char const* proxyURLSuffix, char*& responseStr); // redefined to return True
    # virtual void implementCmd_REGISTER(char const* url, char const* urlSuffix, int socketToRemoteServer,
        Boolean deliverViaTCP, char const* proxyURLSuffix);
    - onRTSPClientCreationFunc* fCreationFunc;
    - int fVerbosityLevel;
    - char* fApplicationName;
}
HandlerServerForREGISTERCommand --|> RTSPServer


class RequestQueue {
    + RequestQueue();
    + RequestQueue(RequestQueue& origQueue);
    + virtual ~RequestQueue();
    + void enqueue(RequestRecord* request);
    + RequestRecord* dequeue();
    + void putAtHead(RequestRecord* request);
    + RequestRecord* findByCSeq(unsigned cseq);
    + Boolean isEmpty() const { return fHead == NULL; }
    - RequestRecord* fHead;
    - RequestRecord* fTail;
}


class RequestRecord {
    + RequestRecord(unsigned cseq, char const* commandName, responseHandler* handler,
          MediaSession* session = NULL, MediaSubsession* subsession = NULL, u_int32_t booleanFlags = 0,
          double start = 0.0f, double end = -1.0f, float scale = 1.0f, char const* contentStr = NULL);
    + RequestRecord(unsigned cseq, responseHandler* handler,
          char const* absStartTime, char const* absEndTime = NULL, float scale = 1.0f,
          MediaSession* session = NULL, MediaSubsession* subsession = NULL);
    + virtual ~RequestRecord();
    + RequestRecord*& next() { return fNext; }
    + unsigned& cseq() { return fCSeq; }
    + char const* commandName() const { return fCommandName; }
    + MediaSession* session() const { return fSession; }
    + MediaSubsession* subsession() const { return fSubsession; }
    + u_int32_t booleanFlags() const { return fBooleanFlags; }
    + double start() const { return fStart; }
    + double end() const { return fEnd; }
    + char const* absStartTime() const { return fAbsStartTime; }
    + char const* absEndTime() const { return fAbsEndTime; }
    + float scale() const { return fScale; }
    + char* contentStr() const { return fContentStr; }
    + responseHandler*& handler() { return fHandler; }
    - RequestRecord* fNext;
    - unsigned fCSeq;
    - char const* fCommandName;
    - MediaSession* fSession;
    - MediaSubsession* fSubsession;
    - u_int32_t fBooleanFlags;
    - double fStart, fEnd;
    - char *fAbsStartTime, *fAbsEndTime;
    - float fScale;
    - char* fContentStr;
    - responseHandler* fHandler;
}


class ProxyRTSPClient {
    + ProxyRTSPClient(class ProxyServerMediaSession& ourServerMediaSession, char const* rtspURL,
        char const* username, char const* password,
        portNumBits tunnelOverHTTPPortNum, int verbosityLevel, int socketNumToServer);
    + virtual ~ProxyRTSPClient();
    + void continueAfterDESCRIBE(char const* sdpDescription);
    + void continueAfterLivenessCommand(int resultCode, Boolean serverSupportsGetParameter);
    + void continueAfterSETUP();
    - void reset();
    - Authenticator* auth() { return fOurAuthenticator; }
    - void scheduleLivenessCommand();
    - static void sendLivenessCommand(void* clientData);
    - void scheduleDESCRIBECommand();
    - static void sendDESCRIBE(void* clientData);
    - static void subsessionTimeout(void* clientData);
    - void handleSubsessionTimeout();
    - friend class ProxyServerMediaSession;
    - friend class ProxyServerMediaSubsession;
    - ProxyServerMediaSession& fOurServerMediaSession;
    - char* fOurURL;
    - Authenticator* fOurAuthenticator;
    - Boolean fStreamRTPOverTCP;
    - class ProxyServerMediaSubsession *fSetupQueueHead, *fSetupQueueTail;
    - unsigned fNumSetupsDone;
    - unsigned fNextDESCRIBEDelay; // in seconds
    - Boolean fServerSupportsGetParameter, fLastCommandWasPLAY;
    - TaskToken fLivenessCommandTask, fDESCRIBECommandTask, fSubsessionTimerTask;
}
ProxyRTSPClient --|> RTSPClient
ProxyRTSPClient --> ProxyServerMediaSession
ProxyRTSPClient --> ProxyServerMediaSubsession


class ServerMediaSession {
    + static ServerMediaSession* createNew(UsageEnvironment& env,
                        char const* streamName = NULL,
                        char const* info = NULL,
                        char const* description = NULL,
                        Boolean isSSM = False,
                        char const* miscSDPLines = NULL);
    + static Boolean lookupByName(UsageEnvironment& env,
                                char const* mediumName,
                                ServerMediaSession*& resultSession);
    + char* generateSDPDescription(); // based on the entire session
    + char const* streamName() const { return fStreamName; }
    + Boolean addSubsession(ServerMediaSubsession* subsession);
    + unsigned numSubsessions() const { return fSubsessionCounter; }
    + void testScaleFactor(float& scale); // sets "scale" to the actual supported scale
    + float duration() const;
    + unsigned referenceCount() const { return fReferenceCount; }
    + void incrementReferenceCount() { ++fReferenceCount; }
    + void decrementReferenceCount() { if (fReferenceCount > 0) --fReferenceCount; }
    + Boolean& deleteWhenUnreferenced() { return fDeleteWhenUnreferenced; }
    + void deleteAllSubsessions();
    # ServerMediaSession(UsageEnvironment& env, char const* streamName,
                char const* info, char const* description,
                Boolean isSSM, char const* miscSDPLines);
    # virtual ~ServerMediaSession();
    - virtual Boolean isServerMediaSession() const;
    - Boolean fIsSSM;
    - friend class ServerMediaSubsessionIterator;
    - ServerMediaSubsession* fSubsessionsHead;
    - ServerMediaSubsession* fSubsessionsTail;
    - unsigned fSubsessionCounter;
    - char* fStreamName;
    - char* fInfoSDPString;
    - char* fDescriptionSDPString;
    - char* fMiscSDPLines;
    - struct timeval fCreationTime;
    - unsigned fReferenceCount;
    - Boolean fDeleteWhenUnreferenced;
}
ServerMediaSession --|> Medium
ServerMediaSession --> ServerMediaSubsessionIterator


class ServerMediaSubsession {
    + unsigned trackNumber() const { return fTrackNumber; }
    + char const* trackId();
    + virtual char const* sdpLines() = 0;
    + virtual void getStreamParameters(unsigned clientSessionId, // in
                    netAddressBits clientAddress, // in
                    Port const& clientRTPPort, // in
                    Port const& clientRTCPPort, // in
                    int tcpSocketNum, // in (-1 means use UDP, not TCP)
                    unsigned char rtpChannelId, // in (used if TCP)
                    unsigned char rtcpChannelId, // in (used if TCP)
                    netAddressBits& destinationAddress, // in out
                    u_int8_t& destinationTTL, // in out
                    Boolean& isMulticast, // out
                    Port& serverRTPPort, // out
                    Port& serverRTCPPort, // out
                    void*& streamToken // out
                    ) = 0;
    + virtual void startStream(unsigned clientSessionId, void* streamToken,
                TaskFunc* rtcpRRHandler,
                void* rtcpRRHandlerClientData,
                unsigned short& rtpSeqNum,
                unsigned& rtpTimestamp,
                ServerRequestAlternativeByteHandler* serverRequestAlternativeByteHandler,
                void* serverRequestAlternativeByteHandlerClientData) = 0;
    + virtual void pauseStream(unsigned clientSessionId, void* streamToken);
    + virtual void seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT,
                double streamDuration, u_int64_t& numBytes);
    + virtual void seekStream(unsigned clientSessionId, void* streamToken, char*& absStart, char*& absEnd);
    + virtual void nullSeekStream(unsigned clientSessionId, void* streamToken,
                    double streamEndTime, u_int64_t& numBytes);
    + virtual void setStreamScale(unsigned clientSessionId, void* streamToken, float scale);
    + virtual float getCurrentNPT(void* streamToken);
    + virtual FramedSource* getStreamSource(void* streamToken);
    + virtual void deleteStream(unsigned clientSessionId, void*& streamToken);
    + virtual void testScaleFactor(float& scale); // sets "scale" to the actual supported scale
    + virtual float duration() const;
    + virtual void getAbsoluteTimeRange(char*& absStartTime, char*& absEndTime) const;
    + void setServerAddressAndPortForSDP(netAddressBits addressBits,
                        portNumBits portBits);
    # ServerMediaSubsession(UsageEnvironment& env);
    # virtual ~ServerMediaSubsession();
    # char const* rangeSDPLine() const;
    # ServerMediaSession* fParentSession;
    # netAddressBits fServerAddressForSDP;
    # portNumBits fPortNumForSDP;
    - friend class ServerMediaSession;
    - friend class ServerMediaSubsessionIterator;
    - ServerMediaSubsession* fNext;
    - unsigned fTrackNumber;
    - char const* fTrackId;
}
ServerMediaSubsession --|> Medium
ServerMediaSubsession --> ServerMediaSession
ServerMediaSubsession --> ServerMediaSubsessionIterator


class ServerMediaSubsessionIterator {
    + ServerMediaSubsessionIterator(ServerMediaSession& session);
    + virtual ~ServerMediaSubsessionIterator();
    + ServerMediaSubsession* next(); // NULL if none
    + void reset();
    - ServerMediaSession& fOurSession;
    - ServerMediaSubsession* fNextPtr;
}


class ProxyServerMediaSession {
    + static ProxyServerMediaSession* createNew(UsageEnvironment& env,
        RTSPServer* ourRTSPServer,
        char const* inputStreamURL,
        char const* streamName = NULL,
        char const* username = NULL, char const* password = NULL,
        portNumBits tunnelOverHTTPPortNum = 0,
        int verbosityLevel = 0,
        int socketNumToServer = -1);
    + virtual ~ProxyServerMediaSession();
    + char const* url() const;
    + char describeCompletedFlag;
    + Boolean describeCompletedSuccessfully() const { return fClientMediaSession != NULL; }
    # ProxyServerMediaSession(UsageEnvironment& env, RTSPServer* ourRTSPServer,
        char const* inputStreamURL, char const* streamName,
        char const* username, char const* password,
        portNumBits tunnelOverHTTPPortNum, int verbosityLevel,
        int socketNumToServer,
        createNewProxyRTSPClientFunc* ourCreateNewProxyRTSPClientFunc
        = defaultCreateNewProxyRTSPClientFunc);
    # RTSPServer* fOurRTSPServer;
    # ProxyRTSPClient* fProxyRTSPClient;
    # MediaSession* fClientMediaSession;
    - friend class ProxyRTSPClient;
    - friend class ProxyServerMediaSubsession;
    - void continueAfterDESCRIBE(char const* sdpDescription);
    - void resetDESCRIBEState(); // undoes what was done by "contineAfterDESCRIBE()"
    - int fVerbosityLevel;
    - class PresentationTimeSessionNormalizer* fPresentationTimeSessionNormalizer;
    - createNewProxyRTSPClientFunc* fCreateNewProxyRTSPClientFunc;
}
ProxyServerMediaSession --|> ServerMediaSession
ProxyServerMediaSession --> ProxyRTSPClient
ProxyServerMediaSession --> ProxyServerMediaSubsession


class MediaSource {
    + static Boolean lookupByName(UsageEnvironment& env, char const* sourceName,
                    MediaSource*& resultSource);
    + virtual void getAttributes() const;
    + virtual char const* MIMEtype() const;
    + virtual Boolean isFramedSource() const;
    + virtual Boolean isRTPSource() const;
    + virtual Boolean isMPEG1or2VideoStreamFramer() const;
    + virtual Boolean isMPEG4VideoStreamFramer() const;
    + virtual Boolean isH264VideoStreamFramer() const;
    + virtual Boolean isH265VideoStreamFramer() const;
    + virtual Boolean isDVVideoStreamFramer() const;
    + virtual Boolean isJPEGVideoSource() const;
    + virtual Boolean isAMRAudioSource() const;
    # MediaSource(UsageEnvironment& env); // abstract base class
    # virtual ~MediaSource();
    - virtual Boolean isSource() const;
}
MediaSource --|> Medium


class FramedSource {
    + static Boolean lookupByName(UsageEnvironment& env, char const* sourceName,
          FramedSource*& resultSource);
    + typedef void(afterGettingFunc)(void* clientData, unsigned frameSize,
          unsigned numTruncatedBytes,
          struct timeval presentationTime,
          unsigned durationInMicroseconds);
    + typedef void(onCloseFunc)(void* clientData);
    + void getNextFrame(unsigned char* to, unsigned maxSize,
          afterGettingFunc* afterGettingFunc,
          void* afterGettingClientData,
          onCloseFunc* onCloseFunc,
          void* onCloseClientData);
    + static void handleClosure(void* clientData);
    + void handleClosure();
    + void stopGettingFrames();
    + virtual unsigned maxFrameSize() const;
    + virtual void doGetNextFrame() = 0;
    + Boolean isCurrentlyAwaitingData() const;
    + static void afterGetting(FramedSource* source);
    # FramedSource(UsageEnvironment& env);
    # virtual ~FramedSource();
    # virtual void doStopGettingFrames();
    # unsigned char* fTo;
    # unsigned fMaxSize;
    # unsigned fFrameSize;
    # unsigned fNumTruncatedBytes;
    # struct timeval fPresentationTime;
    # unsigned fDurationInMicroseconds;
    - virtual Boolean isFramedSource() const;
    - afterGettingFunc* fAfterGettingFunc;
    - void* fAfterGettingClientData;
    - onCloseFunc* fOnCloseFunc;
    - void* fOnCloseClientData;
    - Boolean fIsCurrentlyAwaitingData;
}
FramedSource --|> MediaSource


class FramedFilter {
    + FramedSource* inputSource() const;
    + void reassignInputSource(FramedSource* newInputSource);
    + void detachInputSource();
    # FramedFilter(UsageEnvironment& env, FramedSource* inputSource);
    # virtual ~FramedFilter();
    # virtual char const* MIMEtype() const;
    # virtual void getAttributes() const;
    # virtual void doStopGettingFrames();
    # FramedSource* fInputSource;
}
FramedFilter --|> FramedSource


class PresentationTimeSubsessionNormalizer {
    + void setRTPSink(RTPSink* rtpSink);
    - friend class PresentationTimeSessionNormalizer;
    - PresentationTimeSubsessionNormalizer(PresentationTimeSessionNormalizer& parent, FramedSource* inputSource, RTPSource* rtpSource,
          char const* codecName, PresentationTimeSubsessionNormalizer* next);
    - virtual ~PresentationTimeSubsessionNormalizer();
    - static void afterGettingFrame(void* clientData, unsigned frameSize, unsigned numTruncatedBytes,
          struct timeval presentationTime, unsigned durationInMicroseconds);
    - void afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime, unsigned durationInMicroseconds);
    - virtual void doGetNextFrame();
    - PresentationTimeSessionNormalizer& fParent;
    - RTPSource* fRTPSource;
    - RTPSink* fRTPSink;
    - char const* fCodecName;
    - PresentationTimeSubsessionNormalizer* fNext;
}
PresentationTimeSubsessionNormalizer --|> FramedFilter
PresentationTimeSubsessionNormalizer --> PresentationTimeSessionNormalizer


class PresentationTimeSessionNormalizer {
    + PresentationTimeSessionNormalizer(UsageEnvironment& env);
    + virtual ~PresentationTimeSessionNormalizer();
    + PresentationTimeSubsessionNormalizer*
    + createNewPresentationTimeSubsessionNormalizer(FramedSource* inputSource, RTPSource* rtpSource, char const* codecName);

    - friend class PresentationTimeSubsessionNormalizer;
    - void normalizePresentationTime(PresentationTimeSubsessionNormalizer* ssNormalizer,
          struct timeval& toPT, struct timeval const& fromPT);
    - void removePresentationTimeSubsessionNormalizer(PresentationTimeSubsessionNormalizer* ssNormalizer);
    - PresentationTimeSubsessionNormalizer* fSubsessionNormalizers;
    - PresentationTimeSubsessionNormalizer* fMasterSSNormalizer;
    - struct timeval fPTAdjustment;
}
PresentationTimeSessionNormalizer --|> Medium
PresentationTimeSessionNormalizer --> PresentationTimeSubsessionNormalizer


class OnDemandServerMediaSubsession {
    protected: // we're a virtual base class
    # OnDemandServerMediaSubsession(UsageEnvironment& env, Boolean reuseFirstSource,
                portNumBits initialPortNum = 6970,
                Boolean multiplexRTCPWithRTP = False);
    # virtual ~OnDemandServerMediaSubsession();
    # virtual char const* sdpLines();
    # virtual void getStreamParameters(unsigned clientSessionId,
                                        netAddressBits clientAddress,
                                        Port const& clientRTPPort,
                                        Port const& clientRTCPPort,
                                        int tcpSocketNum,
                                        unsigned char rtpChannelId,
                                        unsigned char rtcpChannelId,
                                        netAddressBits& destinationAddress,
                                        u_int8_t& destinationTTL,
                                        Boolean& isMulticast,
                                        Port& serverRTPPort,
                                        Port& serverRTCPPort,
                                        void*& streamToken);
    # virtual void startStream(unsigned clientSessionId, void* streamToken,
                                TaskFunc* rtcpRRHandler,
                                void* rtcpRRHandlerClientData,
                                unsigned short& rtpSeqNum,
                                unsigned& rtpTimestamp,
                                ServerRequestAlternativeByteHandler* serverRequestAlternativeByteHandler,
                                void* serverRequestAlternativeByteHandlerClientData);
    # virtual void pauseStream(unsigned clientSessionId, void* streamToken);
    # virtual void seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT, double streamDuration, u_int64_t& numBytes);
    # virtual void seekStream(unsigned clientSessionId, void* streamToken, char*& absStart, char*& absEnd);
    # virtual void nullSeekStream(unsigned clientSessionId, void* streamToken,
                      double streamEndTime, u_int64_t& numBytes);
    # virtual void setStreamScale(unsigned clientSessionId, void* streamToken, float scale);
    # virtual float getCurrentNPT(void* streamToken);
    # virtual FramedSource* getStreamSource(void* streamToken);
    # virtual void deleteStream(unsigned clientSessionId, void*& streamToken);
    # virtual char const* getAuxSDPLine(RTPSink* rtpSink,
                      FramedSource* inputSource);
    # virtual void seekStreamSource(FramedSource* inputSource, double& seekNPT, double streamDuration, u_int64_t& numBytes);
    # virtual void seekStreamSource(FramedSource* inputSource, char*& absStart, char*& absEnd);
    # virtual void setStreamSourceScale(FramedSource* inputSource, float scale);
    # virtual void setStreamSourceDuration(FramedSource* inputSource, double streamDuration, u_int64_t& numBytes);
    # virtual void closeStreamSource(FramedSource* inputSource);
    # protected: // new virtual functions, defined by all subclasses
    # virtual FramedSource* createNewStreamSource(unsigned clientSessionId,
                              unsigned& estBitrate) = 0;
    # virtual RTPSink* createNewRTPSink(Groupsock* rtpGroupsock,
                      unsigned char rtpPayloadTypeIfDynamic,
                      FramedSource* inputSource) = 0;
    # virtual Groupsock* createGroupsock(struct in_addr const& addr, Port port);
    + void multiplexRTCPWithRTP() { fMultiplexRTCPWithRTP = True; }
    + void setRTCPAppPacketHandler(RTCPAppHandlerFunc* handler, void* clientData);
    + void sendRTCPAppPacket(u_int8_t subtype, char const* name,
                u_int8_t* appDependentData, unsigned appDependentDataSize);
    - void setSDPLinesFromRTPSink(RTPSink* rtpSink, FramedSource* inputSource,
                    unsigned estBitrate);
    # char* fSDPLines;
    # HashTable* fDestinationsHashTable; // indexed by client session id
    # private:
    # Boolean fReuseFirstSource;
    # portNumBits fInitialPortNum;
    # Boolean fMultiplexRTCPWithRTP;
    # void* fLastStreamToken;
    # char fCNAME[100]; // for RTCP
    # RTCPAppHandlerFunc* fAppHandlerTask;
    # void* fAppHandlerClientData;
    # friend class StreamState;
}
OnDemandServerMediaSubsession --|> ServerMediaSubsession
OnDemandServerMediaSubsession --> StreamState


class Destinations {
    + Destinations(struct in_addr const& destAddr,
                    Port const& rtpDestPort,
                    Port const& rtcpDestPort);
    + Destinations(int tcpSockNum, unsigned char rtpChanId, unsigned char rtcpChanId);
    + Boolean isTCP;
    + struct in_addr addr;
    + Port rtpPort;
    + Port rtcpPort;
    + int tcpSocketNum;
    + unsigned char rtpChannelId, rtcpChannelId;
}


class StreamState {
    + StreamState(OnDemandServerMediaSubsession& master,
                Port const& serverRTPPort, Port const& serverRTCPPort,
                RTPSink* rtpSink, BasicUDPSink* udpSink,
                unsigned totalBW, FramedSource* mediaSource,
                Groupsock* rtpGS, Groupsock* rtcpGS);
    + virtual ~StreamState();
    + void startPlaying(Destinations* destinations,
                        TaskFunc* rtcpRRHandler, void* rtcpRRHandlerClientData,
                        ServerRequestAlternativeByteHandler* serverRequestAlternativeByteHandler,
                        void* serverRequestAlternativeByteHandlerClientData);
    + void pause();
    + void sendRTCPAppPacket(u_int8_t subtype, char const* name,
                u_int8_t* appDependentData, unsigned appDependentDataSize);
    + void endPlaying(Destinations* destinations);
    + void reclaim();
    + unsigned& referenceCount() { return fReferenceCount; }
    + Port const& serverRTPPort() const { return fServerRTPPort; }
    + Port const& serverRTCPPort() const { return fServerRTCPPort; }
    + RTPSink* rtpSink() const { return fRTPSink; }
    + float streamDuration() const { return fStreamDuration; }
    + FramedSource* mediaSource() const { return fMediaSource; }
    + float& startNPT() { return fStartNPT; }
    + private:
    + OnDemandServerMediaSubsession& fMaster;
    + Boolean fAreCurrentlyPlaying;
    + unsigned fReferenceCount;
    + Port fServerRTPPort, fServerRTCPPort;
    + RTPSink* fRTPSink;
    + BasicUDPSink* fUDPSink;
    + float fStreamDuration;
    + unsigned fTotalBW;
    + RTCPInstance* fRTCPInstance;
    + FramedSource* fMediaSource;
    + float fStartNPT;
    + Groupsock* fRTPgs;
    + Groupsock* fRTCPgs;
}
StreamState --> Destinations


class ProxyServerMediaSubsession {
    + ProxyServerMediaSubsession(MediaSubsession& mediaSubsession);
    + virtual ~ProxyServerMediaSubsession();
    + char const* codecName() const { return fClientMediaSubsession.codecName(); }
    + char const* mediumName() const { return fClientMediaSubsession.mediumName(); }
    + unsigned char rtpPayloadFormat() const { return fClientMediaSubsession.rtpPayloadFormat(); }
    + virtual FramedSource* createNewStreamSource(unsigned clientSessionId,
          unsigned& estBitrate);
    + virtual void closeStreamSource(FramedSource* inputSource);
    + virtual RTPSink* createNewRTPSink(Groupsock* rtpGroupsock,
        unsigned char rtpPayloadTypeIfDynamic,
        FramedSource* inputSource);
    - static void subsessionByeHandler(void* clientData);
    - void subsessionByeHandler();
    - int verbosityLevel() const { return ((ProxyServerMediaSession*)fParentSession)->fVerbosityLevel; }
    - friend class ProxyRTSPClient;
    - MediaSubsession& fClientMediaSubsession; // the 'client' media subsession object that corresponds to this 'server' media subsession
    - ProxyServerMediaSubsession* fNext; // used when we're part of a queue
    - Boolean fHaveSetupStream;
}
ProxyServerMediaSubsession --|> OnDemandServerMediaSubsession
ProxyServerMediaSubsession --> ProxyRTSPClient


@enduml